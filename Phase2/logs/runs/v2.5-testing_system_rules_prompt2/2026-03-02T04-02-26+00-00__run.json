{
  "timestamp": "2026-03-02T04:02:26+00:00",
  "query": "Do AI coding assistants increase long-term maintenance burden?",
  "retrieval_query": "Are AI coding assistants associated with increased long-term maintenance burdens in software development?",
  "query_rewritten": true,
  "rewritten_query": "Are AI coding assistants associated with increased long-term maintenance burdens in software development?",
  "top_k": 6,
  "answer": "According to the provided evidence chunks, here are some answers:\n\n1. What is the impact of AI-assisted coding tools on software quality metrics?\nThe paper provided empirical evidence that through the use of assistance from AI in code production, there was a significant impact on software quality metrics namely, cyclomatic complexity, maintainability index and code smell density.\n\n2. Does AI-assisted programming accelerate debt accumulation in software development?\nYes, by lowering the cost of producing code, AI-assisted programming encourages rapid iteration and experimentation, but can shift attention away from longer-term concerns such as maintainability, readability, and alignment with existing system design.\n\n3. What are the potential risks associated with AI-generated code?\nInitial experiments have pointed out issues such as security flaws, licensing confusion, and the occurrence of hidden bugs that will not be discovered during code reviewing process.\n\n4. Can AI-assisted coding tools increase coordination and review burdens among developers?\nYes, our findings reveal that AI-assisted contributions from peripheral developers increase coordination and review burdens on core contributors, who take on the maintenance-related tasks in the project.\n\n5. What is the impact of AI-assisted programming on software maintenance challenges for core contributors?\nThe introduction of GitHub Copilot leads to a significant increase in maintenance-related activities, as AI-generated contributions require more revisions before integration - an early indicator of technical debt accumulation.",
  "citations": [],
  "citations_valid": true,
  "invalid_citations": [],
  "references_consistent": false,
  "retrieved": [
    {
      "rank": 1,
      "distance_l2": 0.6958304047584534,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_027",
      "text": " the project. As a\nresult, maintainers are compelled to reallocate their time toward reviewing and managing code submissions\ninstead of writing new code.\n7.2.\nContributions and Future Research\nExtant research on AI pair programming has primarily emphasized productivity and efficiency gains, sug-\ngesting that tools such as GitHub Copilot can substantially accelerate software development (Peng et al.\n2023). While these benefits are evident in our data, our findings reveal a more nuanced set of consequences.\nIn particular, we show that AI-assisted programming also amplifies software maintenance challenges, espe-\ncially for core contributors who bear responsibility for code review and integration. Our individual-level\nanalysis demonstrates that while less-experienced contributors increase their output, experienced contrib-\nutors face higher review workloads and a concomitant decline in their own development activity. These\nresults highlight a redistribution of effort within OSS communities that has received limited attention in\nprior work.\nFrom a technical debt perspective, our findings suggest that AI-assisted programming alters the intertem-\nporal trade-off between short-term development speed and long-term maintainability. The shortcuts enabled\nby AI tools may accelerate the output while introducing code that is difficult to integrate, extend, or refactor.\nThe widespread use of AI-assisted pair programming - and, in extreme cases, “vibe coding” - can inject a\nlarger volume of difficult-to-maintain code (Pimenova et al. 2025, Fawzy et al. 2025) into software projects,\naccelerating the accumulation of technical debt. Such contributions create latent liabilities for projects, as\nmaintainers must later invest substantial effort to review, revise, or rewrite code to meet repository stan-\ndards. In this sense, AI does not merely increase the volume of contributions; it changes the composition of\nincoming code in ways that intensify technical debt accumulation.\nA key contribution of our study is to operationalize technical debt at its point of entry. We conceptual-\nize extensive PR rework as realized technical debt: the additional modification, coordination, and revision\n16 https://github.blog/news-insights/octoverse/octoverse-2024/\n24\neffort required to bring submitted code up to acceptable standards. This measure complements prior work\nthat captures technical debt through architectural metrics, defect accumulation, or long-run performance\noutcomes. By focusing on PR-level dynamics, we provide a micro-level view of how technical debt emerges\nin real time and how it is managed through ongoing maintenance effort.\nOur findings also raise concerns about the learning implications of AI-assisted development. With AI\nproviding rapid solutions, peripheral contributors may engage less deeply with underlying programming\nprinciples and best practices, resulting in code that is functional but brittle. This concern echoes evidence\nfrom other AI-augmented work settings, where less-experienced workers experience large productivity\ngains while more skilled workers see modest improvements and increased coordination burdens (Brynjolf-\nsson et al. 2025). In OSS settings, these dynamics can further worsen technical debt by weakening the\nfeedback loop between contribution and learning.\nThese insights point to several directions for future research. Scholars could examine how different\nproject governance mechanisms moderate AI-induced technical debt, such as automated testing, mod-\nular architectures, or formalized review protocols. Future work may also explore heterogeneity across\nproject types, identifying which OSS projects are most vulnerable to debt accumulation"
    },
    {
      "rank": 2,
      "distance_l2": 0.7348079681396484,
      "source_id": "EmpiricalToolAnalysis2025",
      "chunk_id": "EmpiricalToolAnalysis2025_chunk_013",
      "text": " we cannot conclude validity of other tools leveraged AI in different forms or \narchitectures. The 60-minute tasks did not allow us to explore the long-term ramifications of maintenance. \nThe sample of practitioners was drawn from Western technology companies and there are implications for \ngeneralizability among practice globally based on our sample. Additionally, the static analysis tools used \nas part of the scanning for a security vulnerability had important limitations, as discussed in several works, \nof being too discriminatory (false positives) and failing to positively identify classes of vulnerabilities that \ncan only be found using a dynamic analysis. Therefore, even with some of the limitations addressed by \nsome manual validation, we evaluated only the immediate introduction of a vulnerability and not the \nprocesses by which a vulnerability is subsequently identified and remediated once a code sample is placed \ninto production software, when investigating a security vulnerability. \n5.5 Future Research Directions \nNumerous important questions springing from our observations will require investigation. Longitudinal \nstudies depicting the development of AI-assisted codebases over extended periods of time will provide \nimportant insights into maintenance costs and the buildup of technical debt. Cross-comparative studies of \ndifferent AI tool implementations will also help clarify whether observed effects are associated with a \nspecific tool, or are more generalizable. Equally pressing, interventions also merit investigation, which \ncould include making AI models security-aware, humans-in-the-loop generation that performs automated \nsecurity-checks, enhanced developer training, or techniques of prompt engineering that pro-actively \nreduce the actual introduction of vulnerabilities. Interactions between AI tooling and developers' own \nskills should also be in steady inquiry, especially whether junior developers using AI tools are developing \nproblem-solving skills equivalent to developers going through training in the traditional sense. The \nanswers to such questions would be noteworthy for educational practice and hiring. Finally, we could \nInternational Journal for Multidisciplinary Research (IJFMR) \n \nE-ISSN: 2582-2160   ●   Website: www.ijfmr.com       ●   Email: editor@ijfmr.com \n \nIJFMR250661350 \nVolume 7, Issue 6, November-December 2025 \n10\n \nconduct research that examines adaptive AI assistance that provides support at each stage based on \ndevelopers' competencies in order to move optimal learning trajectories forward, and that also assesses \nproductivity gains in relationship to skills development. \n \n6. Conclusion \nIn this study, we provide an in-depth data-driven investigation of AI-assisted code generation technologies \nthat demonstrate considerable productivity increases (i.e., an average of 31.4%) and, concerning, a total \nincrease in vulnerabilities of 23.7% and a total increase in critical severity of 89%. We also demonstrate \nthat some dimensions of code quality are improved with AI-assisted code generation tools (i.e., \nmaintainability, cyclomatic complexity) but caution is warranted with operational risks, to code itself (i.e. \nextra code duplication) and security vulnerabilities. We also examined differences across programming \nlanguages, and in particular, we found that while using AI-assisted code generation technologies is \nconstructive in Python, it warrants heightened caution around codex in C++ (to name only one). Finally, \nwhile we examined experience differences, we found that junior developers require support to prevent \nexcessive dependency on AI and senior developers could receive the maximum"
    },
    {
      "rank": 3,
      "distance_l2": 0.7973507642745972,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_004",
      "text": "1, Ramasubbu and Kemerer 2021). These maintenance tasks are generally less intrinsically driven and\ntypically assigned to contributors who possess both technical expertise and trust of the community to ensure\nthe quality and reliability of the codebase (Medappa et al. 2023, Eghbal 2020). Thus, we seek to answer the\nquestion: How does AI-assisted programming impact the development and maintenance activities and the\ntechnical debt of the OSS projects?\nIn this study, we examine whether technical debt and maintenance efforts of OSS projects changed after\nthe introduction of GitHub Copilot through increased code review and rework effort on PRs. To empirically\ntest this, we exploit the release of GitHub Copilot as a technical preview in June 2021, which included lim-\nited programming language endorsement. We focus on OSS projects owned by Microsoft, as the company\nhad exclusive access to OpenAI’s GPT-3, the model powering GitHub Copilot during its technical preview,\ndue to its investment in OpenAI and its prior acquisition of GitHub.4,5 The individual users in our dataset\nare contributors to Microsoft-owned OSS projects. We estimate the effect of Copilot at both the project\nand contributor levels using a Difference-in-Differences (DiD) design. Treatment and control groups were\ndefined based on the primary programming language: those using Copilot-endorsed languages formed the\ntreatment group, while non-endorsed language users served as the control (Yeverechyahu et al. 2024). For\nboth project and contributor levels, we collected data on programming activities and aggregated them at the\nmonthly level.\nWe examine the changes in code productivity after Copilot by three measures: lines of code added,\ncommits 6 and PRs submitted to the project. To capture the secondary effects of AI adoption on technical\ndebt and maintenance effortsof OSS communities, we focused on two complementary outcomes. First, we\n4 https://www.technologyreview.com/2020/09/23/1008729/openai-is-giving-microsoft-exclusive-access-to-its-gpt-3-language-\nmodel/\n5 https://www.mckinsey.com/industries/technology-media-and-telecommunications/our-insights/thomas-dohmke-on-improving-\nengineering-experience-using-generative-ai\n6 A commit is the fundamental unit of change on GitHub. Similar to saving a file that’s been edited, a commit records changes to\none or more files on GitHub - https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-\ncommits/about-commits\n4\nmeasured technical debt at the project level using PR rework, which reflects the extent to which initially\nsubmitted contributions require modification before being integrated into the codebase (Ramasubbu and\nKemerer 2016, 2021). Higher levels of rework indicate greater reliance on expedient or insufficiently inte-\ngrated solutions. Second, we measured maintenance effort at the individual level using PR reviews, which\ncapture the time and effort required from contributors to evaluate, correct, and integrate submitted code\n(Medappa et al. 2023).\nBased on our analysis of a large-scale panel dataset from GitHub, we find that while AI adoption leads to\nproductivity gains, they also increase maintenance-related activities"
    },
    {
      "rank": 4,
      "distance_l2": 0.8091253042221069,
      "source_id": "EmpiricalToolAnalysis2025",
      "chunk_id": "EmpiricalToolAnalysis2025_chunk_002",
      "text": " code \ngeneration tools, which are based on huge language models that have been trained with billions of lines \nof code, have been identified as the most powerful of the innovative technologies that will significantly \ncontribute to the developer's productivity, lessening of cognitive burden, and speeding up of software \ndelivery cycles [1, 2]. In this manner interaction with such tools as GitHub Copilot, Amazon \nCodeWhisperer, and ChatGPT-based coding assistants radically changes the way developers write and \nmaintain software since they all provide real-time code suggestions, automated bug fixes, and intelligent \nInternational Journal for Multidisciplinary Research (IJFMR) \n \nE-ISSN: 2582-2160   ●   Website: www.ijfmr.com       ●   Email: editor@ijfmr.com \n \nIJFMR250661350 \nVolume 7, Issue 6, November-December 2025 \n2\n \ncode completion capabilities [3].The acceptance of AI-assisted coding tools is getting faster, and it is \nrevealed by the latest industry surveys, which show that more than 65% of professional developers use AI \nsupport in some form as part of their daily routine [4]. These tools have been incorporated into the \ndevelopment processes of large tech companies that account for 30-50% productivity gains and have also \nreported significant time-to-market reductions for software products [5]. Nevertheless, the fast adoption \nof these tools has been so extensive that even empirical studies have not been able to catch up with their \nimplications on critical software engineering outcomes, like code quality, security, and long-term \nmaintainability, through rigorous research [6]. \nThe research gap is even more pronounced when the risk factors of AI-generated code are taken into \naccount. Initial experiments have pointed out issues such as security flaws, licensing confusion, and the \noccurrence of hidden bugs that will not be discovered during code reviewing process [7, 8]. Moreover, the \nimpact on the development of programmers' skills, particularly that of junior developers, who would \notherwise depend on AI-generated suggestions, is still unclear [9]. There being no empirical studies taking \na comprehensive approach to the assessment of these issues, the bottleneck of knowledge in software \nengineering research is in fact the multifaceted impacts of these issues. \nThis research paper fills this void by performing a large-scale controlled experiment whose main objective \nis to evaluate in a systematic way the impact of AI-assisted code generator tools on the three main \ndimensions: code quality, security vulnerability introduction, and developer productivity. Previous studies \nhave limited themselves to specific scenarios or synthetic benchmarks. On the contrary, our study will \ninvolve actual programming tasks in different languages and varying degrees of complexity, professional \ndevelopers of different skill and experience levels. Our assumption is that although the use of AI-assisted \ntools will increase productivity, at the same time, they might lead to the poor quality and insecure software \ndevelopment, which will need to be dealt with through proper industrial adoption strategies. \nResearch has contributed in three ways. To start with, the paper provided empirical evidence that through \nthe use of assistance from AI in code production, there was a significant impact on the software quality \nmetrics namely, cyclomatic complexity, maintainability index and code smell density. Next, the authors \nperformed a comprehensive examination of the security vulnerabilities related to AI-generated code in the \nvarious"
    },
    {
      "rank": 5,
      "distance_l2": 0.8216205835342407,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_009",
      "text": " Ramasubbu and Kemerer 2021). Both approaches have value: the former\nmetric-based techniques are scalable and actionable for tooling, while the later process indicators capture\nthe economic and human costs that managers and maintainers ultimately face.\nEmpirical studies across industry and OSS ecosystems consistently find that technical debt impairs long-\nrun productivity and increases maintenance burdens (Paramitha and Massacci 2023). Work in empirical\nsoftware engineering shows that higher measured debt correlates with increased bug rates, longer defect\nresolution times, and reduced velocity for feature delivery (Ramasubbu and Kemerer 2016). Rinta-Kahila\net al. (2023) further demonstrate that organizations can become “trapped” in technical debt due to coor-\ndination failures, organizational inertia, and escalating switching costs. The introduction of GenAI tools\nsuch as GitHub Copilot represents a departure from these assumptions (Yeverechyahu et al. 2024). Unlike\nprior productivity-enhancing tools, GenAI dramatically lowers the marginal cost of producing code and\nreduces skill barriers to contribution (Peng et al. 2023). While prior studies document productivity gains\nfrom AI-assisted coding, they provide limited insight into how these gains translate into technical debt and\nmaintenance related challenges.\nFrom a technical debt perspective, GenAI may accelerate debt accumulation by increasing code volume\nwithout proportionate improvements in quality, the integration with the software, or architectural coher-\nence (Pimenova et al. 2025). By lowering the cost of producing code, AI-assisted programming encourages\nrapid iteration and experimentation, but can shift attention away from longer-term concerns such as main-\ntainability, readability, and alignment with existing system design (Barrett et al. 2023, Schreiber and Tippe\n2025). As a result, defects, inconsistencies, and design shortcuts may be introduced more quickly than\nthey can be identified and resolved. Over time, this imbalance can compound, transforming short-term pro-\nductivity gains into persistent maintenance obligations that must be absorbed by experienced developers\n(Eghbal 2020). While GenAI promises to enhance development speed and broaden participation, it may\nsimultaneously intensify the very technical debt that constrains system reliability, scalability, and long-run\nperformance (Ramasubbu and Kemerer 2021). If this logic is valid, we expect that GenAI may lead to a\ngreater accumulation of technical debt in OSS projects.\n8\nTable 1\nSelected Literature on Technical Debt and Software Maintenance\nStudy\nContext\nMethod\nMeasurement\nKey Findings\nBanker et al.\n(2021)\nCustomer\nrelationship\nmanagement\n(CRM)\nsystems in 26 firms\nEconometric analysis\nPercentage of customized codes in the\nCRM system that do not adhere to vendor-\nprescribed standard\nHigher technical debt is associated\nwith\nlower\nfirm\nperformance\nand\nreduced operational efficiency over\ntime.\nRamasubbu\n&\nKemerer\n(2021)\nOutsourced Commercial\nOff-The-Shelf\n(COT)\nenterprise systems\nEconometric analysis\nViolations of the design and programming\nstandards established by the vendor of the\nCOTS enterprise system\nActive remediation policies reduce\nlong-term\nmaintenance\ncosts,\nbut\nexcessive deferral leads to escalating\ntechnical debt.\nRamas"
    },
    {
      "rank": 6,
      "distance_l2": 0.8244442343711853,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_026",
      "text": ". First, the introduction of GitHub Copilot leads to higher\ndevelopment activity at both the repository and individual levels, measured by commits and PR, consistent\nwith industry evidence on AI-driven productivity gains (Peng et al. 2023). Second, these gains are accompa-\nnied by a significant increase in maintenance-related activities, as AI-generated contributions require more\nrevisions before integration - an early indicator of technical debt accumulation. Third, the effects are highly\nheterogeneous: core contributors review more PRs, contribute fewer commits, and extend their mainte-\nnance responsibilities across a wider range of repositories, suggesting that AI-assisted contributions from\nperipheral developers increase coordination and review burdens.\nBy conceptualizing GenAI as an endogenous shock to software production, this study advances the tech-\nnical debt literature in several important ways. First, consistent with prior work linking technical debt to firm\nperformance (Banker et al. 2021) and remediation costs (Ramasubbu and Kemerer 2016, 2021), we demon-\nstrate that AI-assisted code increases realized remediation effort, measured through PR rework. Second, we\nshow that technical debt is increasingly an outdated workload distribution phenomenon: maintenance costs\nare concentrated among a shrinking pool of core contributors, whose own productive output declines as\nmaintenance demands rise. Third, our findings complement research on organizational design and auton-\nomy (Paramitha and Massacci 2023, Yoo et al. 2025) by revealing how technological change can exacerbate\nasymmetries in effort and responsibility, even when the OSS repository workflow remains unchanged.\n15 https://mashable.com/archive/heartbleed-bug-websites-affected\n23\nTo illustrate the scale of Copilot’s impact on OSS communities, Microsoft core contributors in our dataset\nconduct on average, 976 commits, 160 PRs, and 166 PR reviews annually before its introduction. The\nincreased volume of code associated with Copilot adoption results in an additional workload – each core\ncontributor is expected to review approximately 10 more PRs annually. This added maintenance burden\ncorresponds to a reduction of 164 commits and 9 PR contributions per year per core contributor. More\ncritically, GitHub’s 2024 surveys reveal that more than one-third of contributors to the 10 most popular OSS\nprojects made their first contribution after signing up for GitHub Copilot, highlighting a significant influx\nof new and often less experienced developers16.\nWith annual contributions to OSS projects approaching 1 billion, this surge in participation significantly\nincreases the burden on core contributors, who take on the maintenance related tasks in the project. As a\nresult, maintainers are compelled to reallocate their time toward reviewing and managing code submissions\ninstead of writing new code.\n7.2.\nContributions and Future Research\nExtant research on AI pair programming has primarily emphasized productivity and efficiency gains, sug-\ngesting that tools such as GitHub Copilot can substantially accelerate software development (Peng et al.\n2023). While these benefits are evident in our data, our findings reveal a more nuanced set of consequences.\nIn particular, we show that AI-assisted programming also amplifies software maintenance challenges, espe-\ncially for core contributors who bear responsibility for code review and integration. Our individual-level\nanalysis demonstrates that while less-experienced contributors increase their output, experienced"
    }
  ],
  "embed_model": "sentence-transformers/all-MiniLM-L6-v2",
  "ollama_model": "llama3",
  "prompt_version": "v2.5-testing_system_rules_prompt2"
}