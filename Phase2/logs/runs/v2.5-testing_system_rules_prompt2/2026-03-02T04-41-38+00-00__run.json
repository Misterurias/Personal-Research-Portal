{
  "timestamp": "2026-03-02T04:41:38+00:00",
  "query": "Does GitHub Copilot increase developer productivity?",
  "retrieval_query": "Is GitHub Copilot effective in improving developer efficiency?",
  "query_rewritten": true,
  "rewritten_query": "Is GitHub Copilot effective in improving developer efficiency?",
  "top_k": 7,
  "answer": "I'll answer based only on the provided evidence chunks.\n\nPlease provide the question or topic you'd like me to address, and I'll respond using only the information from these evidence chunks.",
  "citations": [],
  "citations_valid": true,
  "invalid_citations": [],
  "references_consistent": false,
  "retrieved": [
    {
      "rank": 1,
      "distance_l2": 0.6032747030258179,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_006",
      "text": " than the control group (Peng et al. 2023). Another\nstudy by GitHub reports that the use of Copilot Chat increases programmers’ confidence, with participants\nself-reporting improvements in code readability, reusability, conciseness, maintainability, and resilience\n(Rodriguez 2023). These productivity gains also translate into labor-market outcomes: developers exposed\nto AI-assisted coding experience faster career progression in the short- to medium-term (Li et al. 2025).\nWork also finds that AI coding assistants reshape the allocation of work. For instance, Yeverechyahu et al.\n5\n(2024) investigate the impact of GitHub Copilot on innovation in OSS projects. They find a significant\nincrease in overall code contributions, accompanied by a shift in the nature of innovation toward more\nroutine and incremental changes. Song et al. (2024) find that Copilot adoption increases project-level code\ncontributions, though this comes at the cost of an increase in coordination time for code integration. Relat-\nedly, Hoffmann et al. (2025) show that access to GitHub Copilot reallocates developers’ effort toward core\ncoding tasks and away from project management and coordination activities.\nWhile AI-assisted code development promises substantial productivity gains, its implications for software\nmaintenance remain less well understood. Prior research on software development has long recognized that\ndevelopment costs are often small relative to maintenance costs, which include sustaining activities associ-\nated with ensuring software quality and security (Nagle 2019). In the case of OSS, while users can benefit\nfrom reduced up-front costs, collective intelligence of the crowd, and flexibility to implement changes, the\nchallenges of maintenance get magnified as contributors are not contractually obligated to maintain the\nsoftware (von Hippel and von Krogh 2003, Nagle 2019). The Linux Foundation’s OSS Contributor Sur-\nvey provides insightful perspectives on the complexities involved in maintaining OSS (Nagle et al. 2020).\nFirstly, it highlights that “general housekeeping\" tasks, such as project maintenance, bug reporting and\ndocumentation, and organizational or administrative duties, often consume a more significant portion of\ncontributors’ time than desired. Secondly, despite a preference among contributors to spend less time on\nmaintenance tasks, there’s a broad acknowledgment of the importance of these activities, especially those\nrelated to software security, for the success and integrity of their projects (Nagle et al. 2020).\nFurthermore, AI code assistants, including prompt-based and “vibe coding” practices, promise to increase\nproductivity while easing access for contributors to submit code, even in complex and mature OSS projects.\nRecent work has begun to examine vibe coding as an emerging and controversial paradigm in AI-assisted\nsoftware development, in which programmers rely on natural language interaction with generative models\nto maintain flow and rapidly explore solutions, often with minimal upfront specification (Pimenova et al.\n2025, Fawzy et al. 2025). While this approach can substantially accelerate development and foster exper-\nimentation, the literature consistently highlights associated risks, including underspecified requirements,\nreduced reliability, difficulties in debugging, increased latency, and heavier burdens on code review and col-\nlaboration (He et al. 2025). A recurring theme is a speed–quality paradox (Fawzy et al. 2025): although vibe\ncoding enables rapid"
    },
    {
      "rank": 2,
      "distance_l2": 0.6153206825256348,
      "source_id": "CopilotQuality2022",
      "chunk_id": "CopilotQuality2022_chunk_003",
      "text": ". GitHub Copilot generates the code\nand presents the results of the OpenAI Codex Model by adjusting\nthe generated code to the current workspace of the programmer\n[4]. The Codex model relies on Generative Pre-trained Transformer\n(GPT) models that the company previously invented for text gen-\neration. The public code available on GitHub was used during the\nfine-tuning of the model to implement the code recognition and\ngeneration capabilities.\nThere are mixed reviews about the prospect of the GitHub Copi-\nlot. On the one hand, reducing development time, easing the devel-\nopment process by suggesting code for small utilities, and suggest-\ning better alternatives for code snippets are some of the positive\nfeedback developers provided [2, 7, 13]. On the other hand, it is\nargued that the current state of technology is not promising enough\nto match human ingenuity. Considering the previous studies, the\nservice requires a vast amount of human interaction, making the\ncoding routine still heavily reliant on the programmer [1].\nThe reviews about GitHub Copilot we touched upon only in-\nclude brief and heuristic feedback in terms of the evaluation of the\nservice. We agree with the general consensus of the opinions about\nGitHub Copilot and find it worthwhile to evaluate the possible en-\nhancements a service like GitHub Copilot can offer. Clearly, GitHub\nCopilot is capable of generating code, but its value is undetermined.\nTo systematically evaluate GitHub Copilot, we propose to construct\nan experimental setup to assess the generated code in terms of\nvalidity, correctness, and efficiency. In this context, we defined the\nfollowing research questions:\nRQ1 What is the quality of the code generated by GitHub Copilot?\nRQ1.1 How valid are GitHub Copilot’s code suggestions?\nRQ1.2 How correct are GitHub Copilot’s code suggestions?\nRQ1.3 How efficient are GitHub Copilot’s code suggestions?\nRQ2 What is the effect of using the docstrings on the generated\ncode quality?\nRQ3 What is the effect of using appropriate function names on the\ngenerated code quality?\nIn the following sections, we first elaborate on our experimental\nsetup in Section 2. In Section 3, we present the results we gathered\nfrom our setup. In Section 4, we share and evaluate our results. In\n1copilot.github.com\n2openai.com/blog/openai-codex/\n3github.com/features/codespaces\n62\nPROMISE ’22, November 17, 2022, Singapore, Singapore\nBurak Yetistiren, Isik Ozsoy, and Eray Tuzun\nSection 5, we discuss factors that might influence the validity of our\nresults. We provide an overview of other works that study GitHub\nCopilot in Section 6. Lastly, we conclude our study in Section 7.\n2\nMETHODOLOGY\nIn our experiment, we used HumanEval dataset [3], which is de-\nscribed in Section 2.1. To address the research questions, we created\nan experimental setup, which systematically evaluates the effective-\nness of GitHub Copilot that is described in Section 2.2. The details\nof our assessment are presented in Sections 2.3–2.5. In Sections\n2.6 and 2.7, we elaborate on the two additional experiments we\ncon"
    },
    {
      "rank": 3,
      "distance_l2": 0.6247721910476685,
      "source_id": "CopilotCACM2022",
      "chunk_id": "CopilotCACM2022_chunk_001",
      "text": "CODE-COMPLETION SYSTEMS OFFERING suggestions \nto a developer in their integrated development \nenvironment (IDE) have become the most frequently \nused kind of programmer assistance.1 When \ngenerating whole snippets of code, they typically use \na large language model (LLM) to predict what the user \nmight type next (the completion) from the context of \nwhat they are working on at the moment (the prompt).2 \nThis system allows for completions at any position in \nMeasuring \nGitHub \nCopilot’s \nImpact on \nProductivity\nDOI:10.1145/3633453\nCase study asks Copilot users about its impact \non their productivity, and seeks to find their \nperceptions mirrored in user data.\nBY ALBERT ZIEGLER, EIRINI KALLIAMVAKOU, X. ALICE LI, \nANDREW RICE, DEVON RIFKIN, SHAWN SIMISTER, \nGANESH SITTAMPALAM, AND EDWARD AFTANDILIAN\n key insights\n\t\n˽ AI pair-programming tools such as GitHub \nCopilot have a big impact on developer \nproductivity. This holds for developers \nof all skill levels, with junior developers \nseeing the largest gains.\n\t\n˽ The reported benefits of receiving AI \nsuggestions while coding span the full \nrange of typically investigated aspects of \nproductivity, such as task time, product \nquality, cognitive load, enjoyment, and \nlearning.\n\t\n˽ Perceived productivity gains are reflected \nin objective measurements of developer \nactivity.\n\t\n˽ While suggestion correctness is \nimportant, the driving factor for these \nimprovements appears to be not \ncorrectness as such, but whether the \nsuggestions are useful as a starting point \nfor further development.\n54    COMMUNICATIONS OF THE ACM  |  MARCH 2024  |  VOL. 67  |  NO. 3\nresearch\nthe code, often spanning multiple \nlines at once.\nPotential benefits of generating \nlarge sections of code automatically \nare huge, but evaluating these sys­\ntems is challenging. Offline evalua­\ntion, where the system is shown a par­\ntial snippet of code and then asked \nto complete it, is difficult not least \nbecause for longer completions there \nare many acceptable alternatives and \nno straightforward mechanism for \nlabeling them automatically.5 An ad­\nditional step taken by some research­\ners3,21,29 is to use online evaluation \nand track the frequency of real us­\ners accepting suggestions, assuming \nthat the more contributions a system \nmakes to the developer’s code, the \nhigher its benefit. The validity of this \nassumption is not obvious when con­\nsidering issues such as whether two \nshort completions are more valuable \nthan one long one, or whether review­\ning suggestions can be detrimental to \nprogramming flow.\nCode completion in IDEs using lan­\nguage models was first proposed in \nHindle et al.,9 and today neural syn­\nthesis tools such as GitHub Copilot, \nCodeWhisperer, and TabNine suggest \ncode snippets within an IDE with the \nexplicitly stated intention to increase \na user’s productivity. Developer pro­\nductivity has many aspects, and a re­\ncent study has shown that tools like \nthese are helpful in ways"
    },
    {
      "rank": 4,
      "distance_l2": 0.6664259433746338,
      "source_id": "OpenSourceImpact2024",
      "chunk_id": "OpenSourceImpact2024_chunk_015",
      "text": " during our panel \nperiod. We select repositories with non-zero size, at least one specified programming language and license, \na description, and no mirror or personal store designation. To exclude ghost or abandoned projects, we \nrequire at least one code submission every six months from 2021 to 2022 and at least one additional activity, \nsuch as a release or creation, each year. As we are interested in evaluating project-level code contributions \nand coordination time involving multiple developers, we focus on repositories with at least three developers \ncontributing each month. Additionally, as discussed in greater detail below, we use IDE4 information to \n \n2 GitHub launched the technical preview of Copilot in June 2021: https://github.blog/2021-06-29-introducing-github-\ncopilot-ai-pair-programmer/. It then announced the formal launch and public availability of Copilot in June 2022: \nhttps://github.blog/2022-06-21-github-copilot-is-generally-available-to-all-developers/. \n3 We choose this endpoint to ensure our results are not influenced by the rise in popularity of Chat GPT, which began \nin early 2023.  \n4 IDE stands for integrated development environment, which is a software application that provides local environments \nfor coding, testing, and debugging. \n 16 \nidentify repositories in the treatment group versus those in the control groups, so we further restrict our \nsample to those that disclose IDE information. These criteria result in a sample of 9,244 repositories. \nTo identify repositories where Copilot was used by developers (i.e., the treatment group), we \ncollaborated with GitHub organization, which provided proprietary aggregated Copilot usage data at the \nrepository level. This dataset indicates the monthly proportion of developers contributing code to a given \nrepository who also used Copilot.5 Since Copilot requires a compatible IDE, we also consider IDE usage. \nDuring our analysis period, only a limited number of IDEs supported Copilot: Visual Studio Code, the \nJetBrains suite of IDEs, Neovim, and Visual Studio.6 To determine IDE usage, we examine the webpages \nof the repositories in our sample to gather information on the IDE usage by contributing developers. We \ncategorize repositories with developers who used Copilot and one of the supported IDEs as our treatment \ngroup, and those using unsupported IDEs and not using Copilot as our control group. In total, our sample \nincludes 5,687 repositories in the treatment group and 3,557 repositories in the control group. We designate \nthe first month when Copilot was supported by IDEs and used by a non-zero proportion of developers as \nthe treatment start time for each repository. The months before this time are defined as the pre-treatment \nperiod and the months after this time as the post-treatment period for each repository, covering the two-\nyear span from 2021 to 2022. \nTo further improve comparability, we restrict the sample to repository-month observations with at \nleast one code contribution. This focus allows us to estimate Copilot’s effect on collaborative development \nin actively maintained projects. Moreover, because the analysis of coordination time requires at least one \ncode contribution to compute acceptance time, this criterion allows us to use the same sample to investigate \nH1 and H2. The final sample includes 7,637 repositories, with 4"
    },
    {
      "rank": 5,
      "distance_l2": 0.6747032999992371,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_002",
      "text": " team member who partners with the developer to create knowledge (Friedman\n2021). Unlike earlier coding automation tools that primarily targeted productivity, GitHub Copilot’s framing\nas a pair programmer signals a deeper shift. It implies that AI may fundamentally reshape how knowledge-\nintensive work is performed, coordinated, and organized, rather than merely accelerating existing tasks.\nFor organizations and communities involved in software development, the addition of AI pair program-\nmers in teams offers the potential for significant productivity gains. Right after the launch of GitHub Copi-\n1\narXiv:2510.10165v3  [econ.GN]  28 Jan 2026\n2\nlot, research shows that developers who use Copilot completed their programming tasks 55.8% faster (Peng\net al. 2023). Such productivity benefits lead to promises of faster time-to-market and increased revenue\nfor organizations developing software applications. Considering these shifts, major tech organizations have\nstarted to increasingly rely on AI in their projects - “more than a quarter of all new code at Google is gen-\nerated by AI, then reviewed and accepted by engineers,\" reported Google CEO Sundar Pichai in January,\n2025.1 Moreover, Microsoft CTO Kevin Scott expects that 95% of all code will be AI-generated by 2030.2\nWhile these productivity gains are promising, they also raise important questions about the quality and\nmaintainability of AI-generated code. Because AI tools can lower the skill barrier for writing code (Dakhel\net al. 2023), AI tools enable broader participation but may also encourage developers to rely on gener-\nated solutions without fully understanding the underlying design rationale and potential integration issues\n(Barrett et al. 2023). Such reliance increases the likelihood of quick fixes that favor short-term function-\nality over long-term maintainability (Barrett et al. 2023). Extant literature characterizes “quick and dirty”\nsoftware customizations made without a complete understanding of their future implications as technical\ndebt, as they undermine system reliability and impose long-term maintenance obligations (Kruchten et al.\n2012, Brown et al. 2010, Banker et al. 2021). As a result, project maintainers must devote additional effort\nto understanding, reviewing, and reworking AI-generated code before it can be safely integrated. In our\ncontext, we contend that the growing reliance on AI-assisted development may accelerate the accumulation\nof technical debt, as design shortcuts taken to expedite system deployment become embedded in software\nsystems (Ramasubbu and Kemerer 2016, 2021).\nThe technical debt and maintenance challenges that AI poses are expected to be especially pronounced\nin distributed software development teams, such as in Open Source Software (OSS) communities. In these\ncommunities, contributors from around the world collaborate, often voluntarily, to develop and maintain\nsoftware that form the digital infrastructure of our society (e.g., Linux, Apache, LaTeX, Python), making\nit freely or cheaply available to the public (Eghbal 2020, Nagle 2019). Despite the voluntary nature of\nwork in these communities, OSS constitutes critical digital infrastructure for modern society, with estimates\nsuggesting that the total cost of reproducing this software would amount to $8.8 trillion (Hoffmann et al.\n2024).3 Given"
    },
    {
      "rank": 6,
      "distance_l2": 0.6839064955711365,
      "source_id": "CodeQualityComparison2023",
      "chunk_id": "CodeQualityComparison2023_chunk_037",
      "text": " 19 of them had reduced percentages of\ncorrectness in the new GitHub Copilot version. When we examined the answers from\nthe two versions of GitHub Copilot, we found that the new version of GitHub Copilot\nfrequently recommended ´pass’, which reduced the correctness of the answer. We\nobserved that GitHub Copilot sometimes answered the problem nearly correctly, and\nsometimes it only answered as ‘pass’ to the same problem. These issues may be related\nTitle Suppressed Due to Excessive Length\n37\nto the undetermined nature of GitHub Copilot. We also noticed that some problems\nwere resolved in the previous version of GitHub Copilot with the correct solutions. Still,\nin the new version of GitHub Copilot, these problems resulted in compilation errors,\nwhich were generally because of forgetting to add an import to the modules.\nOur research also showed that while the earlier version of Amazon CodeWhisperer\noffered entirely correct suggestions, the new version provided partial or incorrect answers\nfor 16 of the 40 problems. Additionally, our research revealed that the new version of\nAmazon CodeWhisperer had reduced correctness rates for 20 of the 50 partly correct\nsolutions offered by the prior version. We noticed that the following were the main\nreasons why code recommendations in the new edition were unsuccessful: Firstly, the\ntool occasionally suggested using a pass statement only, which is an incorrect response\nto the problem at hand. Second, as was already stated, it occasionally returned default\nnumbers that did not fulfill the required solution. Thirdly, it proposed a single-line\nreturn expression that was complicated and often failed to produce correct results. For\ninstance, Listing 15 presents that problem #155 wanted the function should take a\nnumber as an input parameter, and the function should return a tuple that has the\nnumber of even and odd digits, respectively. The new Amazon CodeWhisperer version\nfor this problem produced a single-line but complicated return statement which gave\na syntactic error for negative numbers. Despite having a long solution, the previous\nversion of Amazon CodeWhisperer had an 85% correctness rate.\n1 def\neven_odd_count (num):\n2\n\"\"\" Given an\ninteger. return a tuple\nthat\nhas the\nnumber of even\nand odd\ndigits\nrespectively .\n3\nExample:\n4\neven_odd_count ( -12) ==> (1, 1)\n5\neven_odd_count (123) ==> (1, 2)\n6\n\"\"\"\n7\n8\n9\n#Result of old\nversion\nof Amazon\nCodeWhisperer\nin the\noriginal\nexperiment\n10\neven = 0\n11\nodd = 0\n12\nif num < 0:\n13\nnum = -num\n14\nwhile\nnum > 0:\n15\nif num % 2 == 0:\n16\neven += 1\n17\nelse:\n18\nodd += 1\n19\nnum = num // 10\n20\nreturn\neven , odd\n21\n22\n#Result of new\nversion\nof Amazon\nCodeWhisperer\nin the\noriginal\nexperiment\n23\nreturn (len ([i for i in str(num) if int(i)%2==0]) , len ([i for i\nin str(num) if int(i)%2]))\nListing 15 Generated Code for the Example Problem ("
    },
    {
      "rank": 7,
      "distance_l2": 0.6870444416999817,
      "source_id": "CopilotQuality2022",
      "chunk_id": "CopilotQuality2022_chunk_023",
      "text": " program generators having the Genetic\nProgramming (GP) architecture. They found that there is not a\nsignificant difference between the two approaches on the bench-\nmark problems; however, the program synthesis approaches are not\nsufficient in supporting programmers compared to GitHub Copilot.\n70\nPROMISE ’22, November 17, 2022, Singapore, Singapore\nBurak Yetistiren, Isik Ozsoy, and Eray Tuzun\nAn evaluation of GitHub Copilot in terms of the security of the\ngenerated programs was implemented by Pearce et al. [10]. They\nevaluated the vulnerabilities in the generated code by Copilot. It\nwas determined that 40% of generated programs were vulnerable.\nAnother study discusses the effects of GitHub Copilot by con-\nducting a within-subjects user study [14]. It was found that GitHub\nCopilot did not cause a significant improvement in terms of speed\nand success rate. However, it was stated that most participants\npreferred to use Copilot in daily programming tasks since it saved\nthe effort for the basic tasks.\nNguyen et al. [9] evaluated GitHub Copilot using 33 different\nLeetCode questions and four different programming languages\n(Python, Java, JavaScript, and C). Their evaluation includes code\ncorrectness and code understandability for the generated code. They\nevaluated code correctness by measuring the ratio of passed tests\nfor each question, which is a similar approach to our study. Code\nunderstandability was measured by two different metrics, which are\ncognitive and cyclomatic complexity. In terms of code correctness,\nJava had the highest (57%) and JavaScript was the lowest (27%)\nscore. For code understandability, they determined that there was\nno statistical significance between the programming languages.\nIn general, most of the related works evaluated the quality of\ncode generated by GitHub Copilot or OpenAI’s Codex model. The\nmajority of the studies focused on the evaluation of code correct-\nness, with the exception of the studies of Pearce et al. [10] where\nthe focus is code security, and Vaithilingam et al. [14] as their work\nmostly concentrates on the practical usage performance of GitHub\nCopilot. To the best of our knowledge, this is the first study that\nevaluates GitHub Copilot in terms of code correctness, code validity,\nand code efficiency. In this sense, we believe that our methodol-\nogy and results will contribute to the ongoing research about the\ncapabilities of GitHub Copilot and other code generation tools.\n7\nCONCLUSION\nIn our study, we performed an analysis on GitHub Copilot to as-\nsess the quality of code generation from correctness, validity, and\nefficiency perspectives. We found that GitHub Copilot was able to\ngenerate valid code for 91.5% of the problems in the HumanEval\nproblem dataset. 28.7% of solutions were correct, 51.2% were par-\ntially correct, and 20.1% of them were incorrect. In terms of effi-\nciency, we observed that Copilot could mostly match the efficiency\nof solutions written by humans.\nTo understand and evaluate the impact of input parameters’\nquality on GitHub Copilot, we first assessed the effect of providing\nonly function names and parameters. Based on the results, 79.3%\nof the solutions were valid compared to"
    }
  ],
  "embed_model": "sentence-transformers/all-MiniLM-L6-v2",
  "ollama_model": "llama3",
  "prompt_version": "v2.5-testing_system_rules_prompt2"
}