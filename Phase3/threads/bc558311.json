{
  "thread_id": "bc558311",
  "timestamp": "2026-03-02T04:38:16+00:00",
  "query": "Does GitHub Copilot increase developer productivity?",
  "answer": "Based on the provided evidence chunks, I can only answer questions related to the research studies on GitHub Copilot's productivity effects, quality of generated code, and technical debt.\n\nPlease feel free to ask specific questions about these topics, and I'll do my best to provide answers based on the evidence chunks.",
  "retrieved": [
    {
      "rank": 1,
      "distance_l2": 0.4739902913570404,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_006",
      "text": " than the control group (Peng et al. 2023). Another\nstudy by GitHub reports that the use of Copilot Chat increases programmers\u2019 confidence, with participants\nself-reporting improvements in code readability, reusability, conciseness, maintainability, and resilience\n(Rodriguez 2023). These productivity gains also translate into labor-market outcomes: developers exposed\nto AI-assisted coding experience faster career progression in the short- to medium-term (Li et al. 2025).\nWork also finds that AI coding assistants reshape the allocation of work. For instance, Yeverechyahu et al.\n5\n(2024) investigate the impact of GitHub Copilot on innovation in OSS projects. They find a significant\nincrease in overall code contributions, accompanied by a shift in the nature of innovation toward more\nroutine and incremental changes. Song et al. (2024) find that Copilot adoption increases project-level code\ncontributions, though this comes at the cost of an increase in coordination time for code integration. Relat-\nedly, Hoffmann et al. (2025) show that access to GitHub Copilot reallocates developers\u2019 effort toward core\ncoding tasks and away from project management and coordination activities.\nWhile AI-assisted code development promises substantial productivity gains, its implications for software\nmaintenance remain less well understood. Prior research on software development has long recognized that\ndevelopment costs are often small relative to maintenance costs, which include sustaining activities associ-\nated with ensuring software quality and security (Nagle 2019). In the case of OSS, while users can benefit\nfrom reduced up-front costs, collective intelligence of the crowd, and flexibility to implement changes, the\nchallenges of maintenance get magnified as contributors are not contractually obligated to maintain the\nsoftware (von Hippel and von Krogh 2003, Nagle 2019). The Linux Foundation\u2019s OSS Contributor Sur-\nvey provides insightful perspectives on the complexities involved in maintaining OSS (Nagle et al. 2020).\nFirstly, it highlights that \u201cgeneral housekeeping\" tasks, such as project maintenance, bug reporting and\ndocumentation, and organizational or administrative duties, often consume a more significant portion of\ncontributors\u2019 time than desired. Secondly, despite a preference among contributors to spend less time on\nmaintenance tasks, there\u2019s a broad acknowledgment of the importance of these activities, especially those\nrelated to software security, for the success and integrity of their projects (Nagle et al. 2020).\nFurthermore, AI code assistants, including prompt-based and \u201cvibe coding\u201d practices, promise to increase\nproductivity while easing access for contributors to submit code, even in complex and mature OSS projects.\nRecent work has begun to examine vibe coding as an emerging and controversial paradigm in AI-assisted\nsoftware development, in which programmers rely on natural language interaction with generative models\nto maintain flow and rapidly explore solutions, often with minimal upfront specification (Pimenova et al.\n2025, Fawzy et al. 2025). While this approach can substantially accelerate development and foster exper-\nimentation, the literature consistently highlights associated risks, including underspecified requirements,\nreduced reliability, difficulties in debugging, increased latency, and heavier burdens on code review and col-\nlaboration (He et al. 2025). A recurring theme is a speed\u2013quality paradox (Fawzy et al. 2025): although vibe\ncoding enables rapid"
    },
    {
      "rank": 2,
      "distance_l2": 0.5242539644241333,
      "source_id": "CopilotCACM2022",
      "chunk_id": "CopilotCACM2022_chunk_001",
      "text": "CODE-COMPLETION SYSTEMS OFFERING suggestions \nto a developer in their integrated development \nenvironment (IDE) have become the most frequently \nused kind of programmer assistance.1 When \ngenerating whole snippets of code, they typically use \na large language model (LLM) to predict what the user \nmight type next (the completion) from the context of \nwhat they are working on at the moment (the prompt).2 \nThis system allows for completions at any position in \nMeasuring \nGitHub \nCopilot\u2019s \nImpact on \nProductivity\nDOI:10.1145/3633453\nCase study asks Copilot users about its impact \non their productivity, and seeks to find their \nperceptions mirrored in user data.\nBY ALBERT ZIEGLER, EIRINI KALLIAMVAKOU, X. ALICE LI, \nANDREW RICE, DEVON RIFKIN, SHAWN SIMISTER, \nGANESH SITTAMPALAM, AND EDWARD AFTANDILIAN\n key insights\n\t\n\u02fd AI pair-programming tools such as GitHub \nCopilot have a big impact on developer \nproductivity. This holds for developers \nof all skill levels, with junior developers \nseeing the largest gains.\n\t\n\u02fd The reported benefits of receiving AI \nsuggestions while coding span the full \nrange of typically investigated aspects of \nproductivity, such as task time, product \nquality, cognitive load, enjoyment, and \nlearning.\n\t\n\u02fd Perceived productivity gains are reflected \nin objective measurements of developer \nactivity.\n\t\n\u02fd While suggestion correctness is \nimportant, the driving factor for these \nimprovements appears to be not \ncorrectness as such, but whether the \nsuggestions are useful as a starting point \nfor further development.\n54    COMMUNICATIONS OF THE ACM  |  MARCH 2024  |  VOL. 67  |  NO. 3\nresearch\nthe code, often spanning multiple \nlines at once.\nPotential benefits of generating \nlarge sections of code automatically \nare huge, but evaluating these sys\u00ad\ntems is challenging. Offline evalua\u00ad\ntion, where the system is shown a par\u00ad\ntial snippet of code and then asked \nto complete it, is difficult not least \nbecause for longer completions there \nare many acceptable alternatives and \nno straightforward mechanism for \nlabeling them automatically.5 An ad\u00ad\nditional step taken by some research\u00ad\ners3,21,29 is to use online evaluation \nand track the frequency of real us\u00ad\ners accepting suggestions, assuming \nthat the more contributions a system \nmakes to the developer\u2019s code, the \nhigher its benefit. The validity of this \nassumption is not obvious when con\u00ad\nsidering issues such as whether two \nshort completions are more valuable \nthan one long one, or whether review\u00ad\ning suggestions can be detrimental to \nprogramming flow.\nCode completion in IDEs using lan\u00ad\nguage models was first proposed in \nHindle et al.,9 and today neural syn\u00ad\nthesis tools such as GitHub Copilot, \nCodeWhisperer, and TabNine suggest \ncode snippets within an IDE with the \nexplicitly stated intention to increase \na user\u2019s productivity. Developer pro\u00ad\nductivity has many aspects, and a re\u00ad\ncent study has shown that tools like \nthese are helpful in ways"
    },
    {
      "rank": 3,
      "distance_l2": 0.5948610901832581,
      "source_id": "NoviceProgramming2024",
      "chunk_id": "NoviceProgramming2024_chunk_024",
      "text": " E.;\net al. On the opportunities and risks of foundation models. arXiv 2021, arXiv:2108.07258.\n7.\nZawacki-Richter, O.; Mar\u00edn, V.I.; Bond, M.; Gouverneur, F. Systematic review of research on artificial intelligence applications in\nhigher education\u2013where are the educators? Int. J. Educ. Technol. High. Educ. 2019, 16, 1\u201327. [CrossRef]\n8.\nKalliamvakou, E. Research: Quantifying GitHub Copilot\u2019s Impact on Developer Productivity and Happiness. GitHub Blog\n2022. Available online: https://github.blog/news-insights/research/research-quantifying-github-copilots-impact-on-developer-\nproductivity-and-happiness/ (accessed on 1 May 2024).\n9.\nPeng, S.; Kalliamvakou, E.; Cihon, P.; Demirer, M. The impact of ai on developer productivity: Evidence from github copilot.\narXiv 2023, arXiv:2302.06590.\n10.\nFinnie-Ansley, J.; Denny, P.; Becker, B.A.; Luxton-Reilly, A.; Prather, J. The robots are coming: Exploring the implications of\nOpenAI Codex on introductory programming. In Proceedings of the 24th Australasian Computing Education Conference, Virtual\nEvent, 14\u201318 February 2022; pp. 10\u201319.\nEduc. Sci. 2024, 14, 1089\n16 of 17\n11.\nYilmaz, R.; Yilmaz, F.G.K. The effect of generative artificial intelligence (AI)-based tool use on students\u2019 computational thinking\nskills, programming self-efficacy and motivation. Comput. Educ. Artif. Intell. 2023, 4, 100147. [CrossRef]\n12.\nBird, C.; Ford, D.; Zimmermann, T.; Forsgren, N.; Kalliamvakou, E.; Lowdermilk, T.; Gazit, I. Taking Flight with Copilot: Early\ninsights and opportunities of AI-powered pair-programming tools. Queue 2022, 20, 35\u201357. [CrossRef]\n13.\nLau, S.; Guo, P. From \u201cBan it till we understand it\u201d to \u201cResistance is futile\u201d: How university programming instructors plan to\nadapt as more students use AI code generation and explanation tools such as ChatGPT and GitHub Copilot. In Proceedings of the\n2023 ACM Conference on International Computing Education Research-Volume 1; Association for Computing Machinery: New York,\nNY, USA, 2023; pp. 106\u2013121.\n14.\nRay, P.P. ChatGPT: A comprehensive review on background, applications, key challenges, bias, ethics, limitations and future\nscope. Internet Things Cyber-Phys. Syst. 2023, 3, 121\u2013154. [CrossRef]\n15.\nYin, J.; Goh, T.T.; Yang, B.; Xiaobin, Y. Conversation technology with micro-learning: The impact of chatbot-based learning on\nstudents\u2019 learning motivation and performance. J. Educ. Comput"
    },
    {
      "rank": 4,
      "distance_l2": 0.6007318496704102,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_001",
      "text": "AI-Assisted Programming Decreases the Productivity of\nExperienced Developers by Increasing the Technical Debt\nand Maintenance Burden\nFeiyang (Amber) Xu, Poonacha K. Medappa, Murat M. Tunc\nMartijn Vroegindeweij, Jan C. Fransoo\nTilburg University, the Netherlands\nf.xu_1@tilburguniversity.edu, p.k.medappa@tilburguniversity.edu, m.m.tunc@tilburguniversity.edu\nw.m.vroegindeweij@tilburguniversity.edu, jan.fransoo@tilburguniversity.edu\nGenAI solutions like GitHub Copilot have been shown to increase the productivity of software developers. Yet prior\nwork remains unclear on the quality of code produced and the challenges of maintaining it in software projects. If quality\ndeclines as volume grows, technical debt accumulates as experienced developers face increased workloads reviewing\nand reworking code from less-experienced contributors. We analyze developer activity in Open Source Software (OSS)\nprojects following the introduction of GitHub Copilot. We find that productivity indeed increases. However, the increase\nin productivity is primarily driven by less-experienced (peripheral) developers. We also find that code written after the\nadoption of AI requires more rework to satisfy repository standards, indicating a potential increase in technical debt.\nImportantly, the added rework burden falls on the more experienced (core) developers, who review 6.5% more code after\nCopilot\u2019s introduction, but show a 19% drop in their original code productivity. More broadly, this finding raises caution\nthat productivity gains of AI may mask the growing burden of maintenance on a shrinking pool of experts, together with\nincreased technical debt for the projects. The results highlight a fundamental tension in AI-assisted software development\nbetween short-term productivity gains and long-term system sustainability.\nKey words: GenAI, GitHub Copilot, Open Source Software, Software Maintenance, Technical Debt,\nDifference-in-Differences\n1.\nIntroduction\nHow will AI shape the future of knowledge-intensive industries? This question has taken on renewed\nsignificance with the recent rise of Genarative AI (GenAI) technologies, which are becoming an integral part\nof daily operations of software development, scientific research, healthcare and other expert-driven fields.\nA prominent example is GitHub Copilot, an AI-powered coding assistant designed to support developers by\ngenerating code suggestions and accelerating routine programming tasks (Peng et al. 2023). When GitHub\nlaunched Copilot, it was introduced as \u201cyour AI pair programmer,\" emphasizing not only its role as an\nautomation tool but also as a team member who partners with the developer to create knowledge (Friedman\n2021). Unlike earlier coding automation tools that primarily targeted productivity, GitHub Copilot\u2019s framing\nas a pair programmer signals a deeper shift. It implies that AI may fundamentally reshape how knowledge-\nintensive work is performed, coordinated, and organized, rather than merely accelerating existing tasks.\nFor organizations and communities involved in software development, the addition of AI pair program-\nmers in teams offers the potential for significant productivity gains. Right after the launch of GitHub Copi-\n1\narXiv:2510.10165v3  [econ.GN]  28 Jan 2026\n2\nlot, research shows that developers who use Copilot completed their programming"
    },
    {
      "rank": 5,
      "distance_l2": 0.6398311853408813,
      "source_id": "CopilotExperiment2023",
      "chunk_id": "CopilotExperiment2023_chunk_006",
      "text": " highest monthly price at which they\nwould be interested in getting noti\ufb01ed about the release of GitHub Copilot. The intention is to\nlearn about developers\u2019 willingness to pay for Copilot as the answer to this question provides\nan upper bound for the developers\u2019 willingness to pay. Figure 8 presents the distribution of the\nirrelevant price separated for the control and treated groups. The average irrelevant price for the\ntreated group is $27.25, and the average irrelevant price for the control group is $16.91, both per\nmonth. The difference is statistically signi\ufb01cant at the 95% level. This result provides indirect\nevidence that treated group bene\ufb01ted from Copilot during their task as their willingness to pay\nis signi\ufb01cantly higher than the control group.\nDiscussion\nThis paper presents evidence on the productivity effects of generative AI tools in software de-\nvelopment. To the best of our knowledge, it is the \ufb01rst controlled experiment to measure the\nproductivity of AI tools in professional software development. Our results suggest that Copilot\nhas statistically and practically signi\ufb01cant impact on productivity: the treated group that has\naccess to GitHub Copilot was able to complete the task 55.8% faster than the control group.\nFurther investigations into the productivity impacts of AI-powered tools in software devel-\nopment are warranted. This study examines a standardized programming task in an experiment\nto obtain a precise measure of productivity, instead of a task where developers collaborate on\nlarge projects in professional proprietary and/or open-source settings. Productivity bene\ufb01ts may\n7\nvary across speci\ufb01c tasks and programming languages, so more research is needed to understand\nhow our results generalizes to other tasks. Finally, this study does not examine the effects of\nAI on code quality. AI assistance can increase code quality if it suggests code better than the\nprogrammer writes, or it can reduce quality if the programmer pays less attention to code. The\ncode quality can have performance and security considerations that can change the real-world\nimpact of AI.\nThe heterogeneous effects identi\ufb01ed in this study warrant close attention. Our results sug-\ngest that less experienced programmers bene\ufb01t more from Copilot. If this result persists in\nfurther studies, the productivity bene\ufb01ts for novice programmers and programmers of older\nage point to important possibilities for skill initiatives that support job transitions into software\ndevelopment.\nThe economic impacts of these models also warrant further research [Manning et al., 2022],\nwith particular attention on their implications for labor market. In 2021, over 4.6 million people\nin the United States worked in computer and mathematical occupations,1 a Bureau of Labor\nStatistics category that includes computer programmers, data scientists, and statisticians. These\nworkers earned $464.8 billion or roughly 2% of US GDP. If the results of this study were to be\nextrapolated to the population level, a 55.8% increase in productivity would imply a signi\ufb01cant\namount of cost savings in the economy and have a notable impact on GDP growth. It is, as of\nyet, unclear how such gains would be distributed and how job tasks would change to incorporate\nAI-powered developer tools. It is important to consider such impacts and to begin research on\nthese implications at the outset ["
    },
    {
      "rank": 6,
      "distance_l2": 0.6419419050216675,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_002",
      "text": " team member who partners with the developer to create knowledge (Friedman\n2021). Unlike earlier coding automation tools that primarily targeted productivity, GitHub Copilot\u2019s framing\nas a pair programmer signals a deeper shift. It implies that AI may fundamentally reshape how knowledge-\nintensive work is performed, coordinated, and organized, rather than merely accelerating existing tasks.\nFor organizations and communities involved in software development, the addition of AI pair program-\nmers in teams offers the potential for significant productivity gains. Right after the launch of GitHub Copi-\n1\narXiv:2510.10165v3  [econ.GN]  28 Jan 2026\n2\nlot, research shows that developers who use Copilot completed their programming tasks 55.8% faster (Peng\net al. 2023). Such productivity benefits lead to promises of faster time-to-market and increased revenue\nfor organizations developing software applications. Considering these shifts, major tech organizations have\nstarted to increasingly rely on AI in their projects - \u201cmore than a quarter of all new code at Google is gen-\nerated by AI, then reviewed and accepted by engineers,\" reported Google CEO Sundar Pichai in January,\n2025.1 Moreover, Microsoft CTO Kevin Scott expects that 95% of all code will be AI-generated by 2030.2\nWhile these productivity gains are promising, they also raise important questions about the quality and\nmaintainability of AI-generated code. Because AI tools can lower the skill barrier for writing code (Dakhel\net al. 2023), AI tools enable broader participation but may also encourage developers to rely on gener-\nated solutions without fully understanding the underlying design rationale and potential integration issues\n(Barrett et al. 2023). Such reliance increases the likelihood of quick fixes that favor short-term function-\nality over long-term maintainability (Barrett et al. 2023). Extant literature characterizes \u201cquick and dirty\u201d\nsoftware customizations made without a complete understanding of their future implications as technical\ndebt, as they undermine system reliability and impose long-term maintenance obligations (Kruchten et al.\n2012, Brown et al. 2010, Banker et al. 2021). As a result, project maintainers must devote additional effort\nto understanding, reviewing, and reworking AI-generated code before it can be safely integrated. In our\ncontext, we contend that the growing reliance on AI-assisted development may accelerate the accumulation\nof technical debt, as design shortcuts taken to expedite system deployment become embedded in software\nsystems (Ramasubbu and Kemerer 2016, 2021).\nThe technical debt and maintenance challenges that AI poses are expected to be especially pronounced\nin distributed software development teams, such as in Open Source Software (OSS) communities. In these\ncommunities, contributors from around the world collaborate, often voluntarily, to develop and maintain\nsoftware that form the digital infrastructure of our society (e.g., Linux, Apache, LaTeX, Python), making\nit freely or cheaply available to the public (Eghbal 2020, Nagle 2019). Despite the voluntary nature of\nwork in these communities, OSS constitutes critical digital infrastructure for modern society, with estimates\nsuggesting that the total cost of reproducing this software would amount to $8.8 trillion (Hoffmann et al.\n2024).3 Given"
    },
    {
      "rank": 7,
      "distance_l2": 0.6459717750549316,
      "source_id": "CopilotQuality2022",
      "chunk_id": "CopilotQuality2022_chunk_003",
      "text": ". GitHub Copilot generates the code\nand presents the results of the OpenAI Codex Model by adjusting\nthe generated code to the current workspace of the programmer\n[4]. The Codex model relies on Generative Pre-trained Transformer\n(GPT) models that the company previously invented for text gen-\neration. The public code available on GitHub was used during the\nfine-tuning of the model to implement the code recognition and\ngeneration capabilities.\nThere are mixed reviews about the prospect of the GitHub Copi-\nlot. On the one hand, reducing development time, easing the devel-\nopment process by suggesting code for small utilities, and suggest-\ning better alternatives for code snippets are some of the positive\nfeedback developers provided [2, 7, 13]. On the other hand, it is\nargued that the current state of technology is not promising enough\nto match human ingenuity. Considering the previous studies, the\nservice requires a vast amount of human interaction, making the\ncoding routine still heavily reliant on the programmer [1].\nThe reviews about GitHub Copilot we touched upon only in-\nclude brief and heuristic feedback in terms of the evaluation of the\nservice. We agree with the general consensus of the opinions about\nGitHub Copilot and find it worthwhile to evaluate the possible en-\nhancements a service like GitHub Copilot can offer. Clearly, GitHub\nCopilot is capable of generating code, but its value is undetermined.\nTo systematically evaluate GitHub Copilot, we propose to construct\nan experimental setup to assess the generated code in terms of\nvalidity, correctness, and efficiency. In this context, we defined the\nfollowing research questions:\nRQ1 What is the quality of the code generated by GitHub Copilot?\nRQ1.1 How valid are GitHub Copilot\u2019s code suggestions?\nRQ1.2 How correct are GitHub Copilot\u2019s code suggestions?\nRQ1.3 How efficient are GitHub Copilot\u2019s code suggestions?\nRQ2 What is the effect of using the docstrings on the generated\ncode quality?\nRQ3 What is the effect of using appropriate function names on the\ngenerated code quality?\nIn the following sections, we first elaborate on our experimental\nsetup in Section 2. In Section 3, we present the results we gathered\nfrom our setup. In Section 4, we share and evaluate our results. In\n1copilot.github.com\n2openai.com/blog/openai-codex/\n3github.com/features/codespaces\n62\nPROMISE \u201922, November 17, 2022, Singapore, Singapore\nBurak Yetistiren, Isik Ozsoy, and Eray Tuzun\nSection 5, we discuss factors that might influence the validity of our\nresults. We provide an overview of other works that study GitHub\nCopilot in Section 6. Lastly, we conclude our study in Section 7.\n2\nMETHODOLOGY\nIn our experiment, we used HumanEval dataset [3], which is de-\nscribed in Section 2.1. To address the research questions, we created\nan experimental setup, which systematically evaluates the effective-\nness of GitHub Copilot that is described in Section 2.2. The details\nof our assessment are presented in Sections 2.3\u20132.5. In Sections\n2.6 and 2.7, we elaborate on the two additional experiments we\ncon"
    }
  ],
  "citations": [],
  "prompt_version": "v2.5-testing_system_rules_prompt3",
  "embed_model": "sentence-transformers/all-MiniLM-L6-v2",
  "ollama_model": "llama3",
  "query_rewritten": true,
  "rewritten_query": "Impact of GitHub Copilot on developer productivity.",
  "citations_valid": true,
  "references_consistent": false
}