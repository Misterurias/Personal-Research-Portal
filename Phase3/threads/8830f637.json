{
  "thread_id": "8830f637",
  "timestamp": "2026-03-02T04:34:30+00:00",
  "query": "Does GitHub Copilot increase developer productivity?",
  "answer": "Based on the provided evidence chunks, here are my answers:\n\n**Question**: What is the impact of GitHub Copilot on productivity?\n\n**Answer**: According to the study (CopilotExperiment2023_chunk_006), the treated group that had access to GitHub Copilot was able to complete a standardized programming task 55.8% faster than the control group.\n\n**Question**: How does GenAI interaction impact developer experience indicators?\n\n**Answer**: The study (DevExperienceGenAI2025_chunk_004) aims to investigate how GenAI interaction impacts productivity indicators, including efficiency, accuracy, and perceived workload during simulated software engineering tasks.",
  "retrieved": [
    {
      "rank": 1,
      "distance_l2": 0.46611031889915466,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_006",
      "text": " than the control group (Peng et al. 2023). Another\nstudy by GitHub reports that the use of Copilot Chat increases programmers\u2019 confidence, with participants\nself-reporting improvements in code readability, reusability, conciseness, maintainability, and resilience\n(Rodriguez 2023). These productivity gains also translate into labor-market outcomes: developers exposed\nto AI-assisted coding experience faster career progression in the short- to medium-term (Li et al. 2025).\nWork also finds that AI coding assistants reshape the allocation of work. For instance, Yeverechyahu et al.\n5\n(2024) investigate the impact of GitHub Copilot on innovation in OSS projects. They find a significant\nincrease in overall code contributions, accompanied by a shift in the nature of innovation toward more\nroutine and incremental changes. Song et al. (2024) find that Copilot adoption increases project-level code\ncontributions, though this comes at the cost of an increase in coordination time for code integration. Relat-\nedly, Hoffmann et al. (2025) show that access to GitHub Copilot reallocates developers\u2019 effort toward core\ncoding tasks and away from project management and coordination activities.\nWhile AI-assisted code development promises substantial productivity gains, its implications for software\nmaintenance remain less well understood. Prior research on software development has long recognized that\ndevelopment costs are often small relative to maintenance costs, which include sustaining activities associ-\nated with ensuring software quality and security (Nagle 2019). In the case of OSS, while users can benefit\nfrom reduced up-front costs, collective intelligence of the crowd, and flexibility to implement changes, the\nchallenges of maintenance get magnified as contributors are not contractually obligated to maintain the\nsoftware (von Hippel and von Krogh 2003, Nagle 2019). The Linux Foundation\u2019s OSS Contributor Sur-\nvey provides insightful perspectives on the complexities involved in maintaining OSS (Nagle et al. 2020).\nFirstly, it highlights that \u201cgeneral housekeeping\" tasks, such as project maintenance, bug reporting and\ndocumentation, and organizational or administrative duties, often consume a more significant portion of\ncontributors\u2019 time than desired. Secondly, despite a preference among contributors to spend less time on\nmaintenance tasks, there\u2019s a broad acknowledgment of the importance of these activities, especially those\nrelated to software security, for the success and integrity of their projects (Nagle et al. 2020).\nFurthermore, AI code assistants, including prompt-based and \u201cvibe coding\u201d practices, promise to increase\nproductivity while easing access for contributors to submit code, even in complex and mature OSS projects.\nRecent work has begun to examine vibe coding as an emerging and controversial paradigm in AI-assisted\nsoftware development, in which programmers rely on natural language interaction with generative models\nto maintain flow and rapidly explore solutions, often with minimal upfront specification (Pimenova et al.\n2025, Fawzy et al. 2025). While this approach can substantially accelerate development and foster exper-\nimentation, the literature consistently highlights associated risks, including underspecified requirements,\nreduced reliability, difficulties in debugging, increased latency, and heavier burdens on code review and col-\nlaboration (He et al. 2025). A recurring theme is a speed\u2013quality paradox (Fawzy et al. 2025): although vibe\ncoding enables rapid"
    },
    {
      "rank": 2,
      "distance_l2": 0.5273729562759399,
      "source_id": "CopilotCACM2022",
      "chunk_id": "CopilotCACM2022_chunk_001",
      "text": "CODE-COMPLETION SYSTEMS OFFERING suggestions \nto a developer in their integrated development \nenvironment (IDE) have become the most frequently \nused kind of programmer assistance.1 When \ngenerating whole snippets of code, they typically use \na large language model (LLM) to predict what the user \nmight type next (the completion) from the context of \nwhat they are working on at the moment (the prompt).2 \nThis system allows for completions at any position in \nMeasuring \nGitHub \nCopilot\u2019s \nImpact on \nProductivity\nDOI:10.1145/3633453\nCase study asks Copilot users about its impact \non their productivity, and seeks to find their \nperceptions mirrored in user data.\nBY ALBERT ZIEGLER, EIRINI KALLIAMVAKOU, X. ALICE LI, \nANDREW RICE, DEVON RIFKIN, SHAWN SIMISTER, \nGANESH SITTAMPALAM, AND EDWARD AFTANDILIAN\n key insights\n\t\n\u02fd AI pair-programming tools such as GitHub \nCopilot have a big impact on developer \nproductivity. This holds for developers \nof all skill levels, with junior developers \nseeing the largest gains.\n\t\n\u02fd The reported benefits of receiving AI \nsuggestions while coding span the full \nrange of typically investigated aspects of \nproductivity, such as task time, product \nquality, cognitive load, enjoyment, and \nlearning.\n\t\n\u02fd Perceived productivity gains are reflected \nin objective measurements of developer \nactivity.\n\t\n\u02fd While suggestion correctness is \nimportant, the driving factor for these \nimprovements appears to be not \ncorrectness as such, but whether the \nsuggestions are useful as a starting point \nfor further development.\n54    COMMUNICATIONS OF THE ACM  |  MARCH 2024  |  VOL. 67  |  NO. 3\nresearch\nthe code, often spanning multiple \nlines at once.\nPotential benefits of generating \nlarge sections of code automatically \nare huge, but evaluating these sys\u00ad\ntems is challenging. Offline evalua\u00ad\ntion, where the system is shown a par\u00ad\ntial snippet of code and then asked \nto complete it, is difficult not least \nbecause for longer completions there \nare many acceptable alternatives and \nno straightforward mechanism for \nlabeling them automatically.5 An ad\u00ad\nditional step taken by some research\u00ad\ners3,21,29 is to use online evaluation \nand track the frequency of real us\u00ad\ners accepting suggestions, assuming \nthat the more contributions a system \nmakes to the developer\u2019s code, the \nhigher its benefit. The validity of this \nassumption is not obvious when con\u00ad\nsidering issues such as whether two \nshort completions are more valuable \nthan one long one, or whether review\u00ad\ning suggestions can be detrimental to \nprogramming flow.\nCode completion in IDEs using lan\u00ad\nguage models was first proposed in \nHindle et al.,9 and today neural syn\u00ad\nthesis tools such as GitHub Copilot, \nCodeWhisperer, and TabNine suggest \ncode snippets within an IDE with the \nexplicitly stated intention to increase \na user\u2019s productivity. Developer pro\u00ad\nductivity has many aspects, and a re\u00ad\ncent study has shown that tools like \nthese are helpful in ways"
    },
    {
      "rank": 3,
      "distance_l2": 0.5870149731636047,
      "source_id": "NoviceProgramming2024",
      "chunk_id": "NoviceProgramming2024_chunk_024",
      "text": " E.;\net al. On the opportunities and risks of foundation models. arXiv 2021, arXiv:2108.07258.\n7.\nZawacki-Richter, O.; Mar\u00edn, V.I.; Bond, M.; Gouverneur, F. Systematic review of research on artificial intelligence applications in\nhigher education\u2013where are the educators? Int. J. Educ. Technol. High. Educ. 2019, 16, 1\u201327. [CrossRef]\n8.\nKalliamvakou, E. Research: Quantifying GitHub Copilot\u2019s Impact on Developer Productivity and Happiness. GitHub Blog\n2022. Available online: https://github.blog/news-insights/research/research-quantifying-github-copilots-impact-on-developer-\nproductivity-and-happiness/ (accessed on 1 May 2024).\n9.\nPeng, S.; Kalliamvakou, E.; Cihon, P.; Demirer, M. The impact of ai on developer productivity: Evidence from github copilot.\narXiv 2023, arXiv:2302.06590.\n10.\nFinnie-Ansley, J.; Denny, P.; Becker, B.A.; Luxton-Reilly, A.; Prather, J. The robots are coming: Exploring the implications of\nOpenAI Codex on introductory programming. In Proceedings of the 24th Australasian Computing Education Conference, Virtual\nEvent, 14\u201318 February 2022; pp. 10\u201319.\nEduc. Sci. 2024, 14, 1089\n16 of 17\n11.\nYilmaz, R.; Yilmaz, F.G.K. The effect of generative artificial intelligence (AI)-based tool use on students\u2019 computational thinking\nskills, programming self-efficacy and motivation. Comput. Educ. Artif. Intell. 2023, 4, 100147. [CrossRef]\n12.\nBird, C.; Ford, D.; Zimmermann, T.; Forsgren, N.; Kalliamvakou, E.; Lowdermilk, T.; Gazit, I. Taking Flight with Copilot: Early\ninsights and opportunities of AI-powered pair-programming tools. Queue 2022, 20, 35\u201357. [CrossRef]\n13.\nLau, S.; Guo, P. From \u201cBan it till we understand it\u201d to \u201cResistance is futile\u201d: How university programming instructors plan to\nadapt as more students use AI code generation and explanation tools such as ChatGPT and GitHub Copilot. In Proceedings of the\n2023 ACM Conference on International Computing Education Research-Volume 1; Association for Computing Machinery: New York,\nNY, USA, 2023; pp. 106\u2013121.\n14.\nRay, P.P. ChatGPT: A comprehensive review on background, applications, key challenges, bias, ethics, limitations and future\nscope. Internet Things Cyber-Phys. Syst. 2023, 3, 121\u2013154. [CrossRef]\n15.\nYin, J.; Goh, T.T.; Yang, B.; Xiaobin, Y. Conversation technology with micro-learning: The impact of chatbot-based learning on\nstudents\u2019 learning motivation and performance. J. Educ. Comput"
    },
    {
      "rank": 4,
      "distance_l2": 0.6212647557258606,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_002",
      "text": " team member who partners with the developer to create knowledge (Friedman\n2021). Unlike earlier coding automation tools that primarily targeted productivity, GitHub Copilot\u2019s framing\nas a pair programmer signals a deeper shift. It implies that AI may fundamentally reshape how knowledge-\nintensive work is performed, coordinated, and organized, rather than merely accelerating existing tasks.\nFor organizations and communities involved in software development, the addition of AI pair program-\nmers in teams offers the potential for significant productivity gains. Right after the launch of GitHub Copi-\n1\narXiv:2510.10165v3  [econ.GN]  28 Jan 2026\n2\nlot, research shows that developers who use Copilot completed their programming tasks 55.8% faster (Peng\net al. 2023). Such productivity benefits lead to promises of faster time-to-market and increased revenue\nfor organizations developing software applications. Considering these shifts, major tech organizations have\nstarted to increasingly rely on AI in their projects - \u201cmore than a quarter of all new code at Google is gen-\nerated by AI, then reviewed and accepted by engineers,\" reported Google CEO Sundar Pichai in January,\n2025.1 Moreover, Microsoft CTO Kevin Scott expects that 95% of all code will be AI-generated by 2030.2\nWhile these productivity gains are promising, they also raise important questions about the quality and\nmaintainability of AI-generated code. Because AI tools can lower the skill barrier for writing code (Dakhel\net al. 2023), AI tools enable broader participation but may also encourage developers to rely on gener-\nated solutions without fully understanding the underlying design rationale and potential integration issues\n(Barrett et al. 2023). Such reliance increases the likelihood of quick fixes that favor short-term function-\nality over long-term maintainability (Barrett et al. 2023). Extant literature characterizes \u201cquick and dirty\u201d\nsoftware customizations made without a complete understanding of their future implications as technical\ndebt, as they undermine system reliability and impose long-term maintenance obligations (Kruchten et al.\n2012, Brown et al. 2010, Banker et al. 2021). As a result, project maintainers must devote additional effort\nto understanding, reviewing, and reworking AI-generated code before it can be safely integrated. In our\ncontext, we contend that the growing reliance on AI-assisted development may accelerate the accumulation\nof technical debt, as design shortcuts taken to expedite system deployment become embedded in software\nsystems (Ramasubbu and Kemerer 2016, 2021).\nThe technical debt and maintenance challenges that AI poses are expected to be especially pronounced\nin distributed software development teams, such as in Open Source Software (OSS) communities. In these\ncommunities, contributors from around the world collaborate, often voluntarily, to develop and maintain\nsoftware that form the digital infrastructure of our society (e.g., Linux, Apache, LaTeX, Python), making\nit freely or cheaply available to the public (Eghbal 2020, Nagle 2019). Despite the voluntary nature of\nwork in these communities, OSS constitutes critical digital infrastructure for modern society, with estimates\nsuggesting that the total cost of reproducing this software would amount to $8.8 trillion (Hoffmann et al.\n2024).3 Given"
    },
    {
      "rank": 5,
      "distance_l2": 0.640936017036438,
      "source_id": "CopilotExperiment2023",
      "chunk_id": "CopilotExperiment2023_chunk_004",
      "text": "the treatment group how helpful they found GitHub Copilot as they worked on the task, as well\nas asked them to estimate how much faster they completed the task compared to how long this\ntask would have taken them without using GitHub Copilot. We also asked the control group to\nestimate the size of the speed gain they would have experienced if they used GitHub Copilot,\nafter showing them a 1-minute demo video.\nResults\nA total of 166 offers were sent during the experiment, and 95 were accepted. The 95 developers\nwere randomly assigned into control and treated groups, with 45 in the treated group and 50 in\ncontrol. Thirty-\ufb01ve developers from both the treated and control groups completed the task and\nsurvey. Figure 5 presents the summary statistics of these participants.\nMost of the participants are in the age group of 25-34 and come from India and Pakistan.\nThis group of participants is also characterized by relatively lower income (median yearly in-\ncome between $10,000-$19,000) compared to US standards but high education level (the ma-\njority have a 4-year degree and above). The group has an average coding experience of 6 years\nand, on average, reported spending 9 hours on coding in a working day.\nFigure 6 plots the distribution between time to completion between treated and control\ngroups. Conditioning on completing the task, the average completion time from the treated\ngroup is 71.17 minutes and 160.89 minutes for the control group. This represents a 55.8% re-\nduction in completion time. The p-value for the t-test is 0.0017, and a 95% con\ufb01dence interval\nfor the improvement is between [21%, 89%]. There are four outliers with time to completion\nabove 300 min. All outliers are in the control group, however our results remain robust if these\noutliers are dropped. This result suggests that Copilot increases average productivity signif-\nicantly in our experiment population. We also \ufb01nd that the treated group\u2019s success rate is 7\n5\nTable 1: Heterogeneous Treatment Effects\nEstimates\nSE\nt-Stat\np-Value\n(Intercept)\n78.01\n67.84\n1.15\n0.2552\nProgramming experience (years)\n8.23\n4.36\n1.90\n0.0629\nHours of programming per day\n-11.70\n4.74\n-2.47\n0.0168\nAge: 25-44\n-74.55\n33.52\n-2.22\n0.0303\nUnemployed\n-35.98\n36.33\n-0.99\n0.3263\nIncome less than $20,000\n0.64\n27.47\n0.02\n0.9814\nNo college\n-36.57\n32.89\n-1.11\n0.2711\nLanguage Preference: Java\n-11.77\n33.16\n-0.35\n0.7240\nLanguage Preference: Python\n22.90\n42.19\n0.54\n0.5895\nNote: This table presents the heterogeneous treatment effects. The results suggest developer with less program-\nming experience are more likely to bene\ufb01t from"
    },
    {
      "rank": 6,
      "distance_l2": 0.6609624624252319,
      "source_id": "CopilotExperiment2023",
      "chunk_id": "CopilotExperiment2023_chunk_006",
      "text": " highest monthly price at which they\nwould be interested in getting noti\ufb01ed about the release of GitHub Copilot. The intention is to\nlearn about developers\u2019 willingness to pay for Copilot as the answer to this question provides\nan upper bound for the developers\u2019 willingness to pay. Figure 8 presents the distribution of the\nirrelevant price separated for the control and treated groups. The average irrelevant price for the\ntreated group is $27.25, and the average irrelevant price for the control group is $16.91, both per\nmonth. The difference is statistically signi\ufb01cant at the 95% level. This result provides indirect\nevidence that treated group bene\ufb01ted from Copilot during their task as their willingness to pay\nis signi\ufb01cantly higher than the control group.\nDiscussion\nThis paper presents evidence on the productivity effects of generative AI tools in software de-\nvelopment. To the best of our knowledge, it is the \ufb01rst controlled experiment to measure the\nproductivity of AI tools in professional software development. Our results suggest that Copilot\nhas statistically and practically signi\ufb01cant impact on productivity: the treated group that has\naccess to GitHub Copilot was able to complete the task 55.8% faster than the control group.\nFurther investigations into the productivity impacts of AI-powered tools in software devel-\nopment are warranted. This study examines a standardized programming task in an experiment\nto obtain a precise measure of productivity, instead of a task where developers collaborate on\nlarge projects in professional proprietary and/or open-source settings. Productivity bene\ufb01ts may\n7\nvary across speci\ufb01c tasks and programming languages, so more research is needed to understand\nhow our results generalizes to other tasks. Finally, this study does not examine the effects of\nAI on code quality. AI assistance can increase code quality if it suggests code better than the\nprogrammer writes, or it can reduce quality if the programmer pays less attention to code. The\ncode quality can have performance and security considerations that can change the real-world\nimpact of AI.\nThe heterogeneous effects identi\ufb01ed in this study warrant close attention. Our results sug-\ngest that less experienced programmers bene\ufb01t more from Copilot. If this result persists in\nfurther studies, the productivity bene\ufb01ts for novice programmers and programmers of older\nage point to important possibilities for skill initiatives that support job transitions into software\ndevelopment.\nThe economic impacts of these models also warrant further research [Manning et al., 2022],\nwith particular attention on their implications for labor market. In 2021, over 4.6 million people\nin the United States worked in computer and mathematical occupations,1 a Bureau of Labor\nStatistics category that includes computer programmers, data scientists, and statisticians. These\nworkers earned $464.8 billion or roughly 2% of US GDP. If the results of this study were to be\nextrapolated to the population level, a 55.8% increase in productivity would imply a signi\ufb01cant\namount of cost savings in the economy and have a notable impact on GDP growth. It is, as of\nyet, unclear how such gains would be distributed and how job tasks would change to incorporate\nAI-powered developer tools. It is important to consider such impacts and to begin research on\nthese implications at the outset ["
    },
    {
      "rank": 7,
      "distance_l2": 0.6688393354415894,
      "source_id": "DevExperienceGenAI2025",
      "chunk_id": "DevExperienceGenAI2025_chunk_004",
      "text": " from the uncontrolled study period. \nThe following research questions are going to be addressed: \nHow does GenAI interaction impact the productivity \nindicators\u2026 \n(1) \u2026 efficiency \n(2) \u2026 accuracy \n(3) \u2026 the developer experience indicator perceived \nworkload \nduring simulated software engineering tasks? \nThis study contributes to emerging research that takes a \ndeveloper-centered view on the developer-GenAI interaction \nin a real-world firm setting.  \n2 Related Work \nGenerative AI (GenAI) refers to AI technology that learns from \ndata to autonomously generate new, meaningful, and \ncontextually appropriate content across various applications \n[10]. GitHub Copilot - from here on referred to only as Copilot \n- is one of several GenAIs that can assist developers by \ngenerating, completing and modifying programming code \nbased on the context of the codebase and natural language \nprompts. \nIt \nis \nintegrated \nin \nsoftware \ndevelopment \nenvironments (IDEs) like VS Code and can function as an \u201cAI \npair programmer\u201d for developers.  \nIn recent years, multiple studies have been conducted to \nevaluate Copilot\u2019s output quality and developers\u2019 productivity \ngains through AI usage. Based on benchmark tasks, Dakhel et \nal. [32] found that Copilot can generate solutions for nearly all \ngiven tasks, but its outputs are less often correct than those of \nhumans, making it a potential asset for experienced \ndevelopers but a liability for novices who may not detect non-\noptimal suggestions. So far, there is no consensus on how to \nbest measure software developers\u2019 productivity, but time \nsavings, acceptance rate of Copilot suggestions, and successful \ncompletion of predefined tasks are frequently considered \nmetrics to evaluate developer productivity in the context of \nAI-assisted programming. Empirical studies using these \nmetrics report mixed results: Bakal et al. [1]  found that \ndevelopers using Copilot accepted 33% of suggestions and \nhad a 20% increase in lines of code; Peng et al. [37] observed \nthat programmers completed an HTTP server task 55.8% \nfaster with Copilot, with the largest productivity gains among \nless experienced programmers; while Vaithilingam et al. [45] \nfound no significant improvement in task time or success, \nthough participants still valued Copilot as a useful starting \npoint for daily programming tasks. In this study, we consider \ntask duration, the number of Copilot\u2019s suggestions, and \nsuccessful \ntask \ncompletion \nas \nproductivity \nmetrics. \nAdditionally, we examine the impact of Copilot interaction \ntypes, \ndevelopers\u2019 \ninteraction \nintensity, \nand \nsoftware \ndevelopment task categories on these metrics. This data is \nalso combined with subjective workload ratings from the \ndevelopers to gain a more nuanced analysis of not solely the \noutput quality and productivity gains of Copilot, but also the \ninteraction behavior and experience with Copilot.  \nSeveral studies in the software engineering context have \ndemonstrated benefits of using mixed-methods approaches \nthat combine objective telemetry, physiological measures and \nDevelopers\u2019 Experience with Generative AI \nICSE SEIP 2026, Rio de Janeiro, Brazil \n \n \nsubjective data to provide deeper insights into developers\u2019 \nexperiences during work [6, 17, 36]. However, only a few \n"
    }
  ],
  "citations": [],
  "prompt_version": "v2.5-testing_system_rules_prompt3",
  "embed_model": "sentence-transformers/all-MiniLM-L6-v2",
  "ollama_model": "llama3",
  "query_rewritten": true,
  "rewritten_query": "How does GitHub Copilot impact developer productivity?",
  "citations_valid": true,
  "references_consistent": false
}