{
  "thread_id": "685ea13c",
  "timestamp": "2026-03-02T02:49:41+00:00",
  "query": "Does Github Co-pilot increase developer productivity?",
  "answer": "I'll only answer from the provided evidence chunks. Go ahead and ask your question!",
  "retrieved": [
    {
      "rank": 1,
      "distance_l2": 0.7745667695999146,
      "source_id": "OpenSourceImpact2024",
      "chunk_id": "OpenSourceImpact2024_chunk_004",
      "text": ", because AI pair programmers not only boost individual code contributions but also encourage \ngreater developer participation. However, because AI pair programmers also encourage more participation \nin discussions on OSS projects, they could lead to longer coordination time for code integration. Moreover, \nwe argue that because of peripheral developers\u2019 lower project familiarity and the limited ability of AI pair \nprogrammers to learn the project\u2019s full context, the increase in project-level code contributions from \nperipheral developers may be smaller than that from core developers. At the same time, code contributed \nby peripheral developers may require more coordination time to integrate than code from core developers. \nOverall, the productivity gains from AI pair programmers may be smaller for peripheral developers than \nfor core developers. \nTo empirically test these hypotheses, we examine how the AI pair programmer, GitHub Copilot, \ninfluences project-level code contributions and coordination time of OSS projects on GitHub, as well as \nhow its effect varies among core versus peripheral developers. GitHub is one of the largest code-hosting \nrepositories based on the Git version control system (Dabbish et al. 2012). In this setting, a repository is a \nfundamental unit that typically contains the source code and resource files for a software project, along with \ninformation related to the project\u2019s evolution history, high-level features, and developer details (Zhang et \nal. 2017). Such repositories are often used to investigate collaborative development practices (Dabbish et \nal. 2012). Our unit of analysis is at the repository-month-level, with the sample period from January 2021 \nto December 2022. To examine our research questions, we use a combination of publicly available data on \nGitHub repositories and proprietary data on Copilot use provided by GitHub organization. Our treatment \n 4 \ngroup consists of repositories where Copilot was both supported by local coding environments and used by \ndevelopers to code. Thus, the post-treatment period includes the months during which Copilot was \nsupported and used in a focal repository, and the pre-treatment period includes all other months. The control \ngroup includes repositories where Copilot was not used throughout the sample period. We estimate our \nmodel using the Generalized Synthetic Control Method (GSCM) and validate the results through alternative \nmatching techniques and a comprehensive set of robustness checks. \nOur empirical results show that the adoption of GitHub Copilot is associated with a 5.9% increase \nin the number of project-level code contributions but also an 8% increase in coordination time for code \nintegration. These findings indicate a tradeoff between contribution gains and coordination time in the OSS \ndevelopment following the adoption of Copilot. Further analysis of the underlying mechanism suggests that \nthe observed increase in project-level code contributions is accompanied by a significant increase in both \nindividual code contributions and developer participation. At the same time, the increase in coordination \ntime is driven by a higher volume of discussions surrounding code contributions, a broader set of developers \nparticipating in these discussions, and greater discussion intensity per developer. Importantly, the combined \neffect of these two competing forces still yields an overall positive effect on the project-level productivity, \nmeasured by the total code contributions with timely integration into the codebase. \nFurthermore, we find that compared to core developers, AI pair programmers lead to a smaller \nincrease in project-level code contributions made by peripheral developers; following the adoption of AI \npair programmers"
    },
    {
      "rank": 2,
      "distance_l2": 0.7887781858444214,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_006",
      "text": " than the control group (Peng et al. 2023). Another\nstudy by GitHub reports that the use of Copilot Chat increases programmers\u2019 confidence, with participants\nself-reporting improvements in code readability, reusability, conciseness, maintainability, and resilience\n(Rodriguez 2023). These productivity gains also translate into labor-market outcomes: developers exposed\nto AI-assisted coding experience faster career progression in the short- to medium-term (Li et al. 2025).\nWork also finds that AI coding assistants reshape the allocation of work. For instance, Yeverechyahu et al.\n5\n(2024) investigate the impact of GitHub Copilot on innovation in OSS projects. They find a significant\nincrease in overall code contributions, accompanied by a shift in the nature of innovation toward more\nroutine and incremental changes. Song et al. (2024) find that Copilot adoption increases project-level code\ncontributions, though this comes at the cost of an increase in coordination time for code integration. Relat-\nedly, Hoffmann et al. (2025) show that access to GitHub Copilot reallocates developers\u2019 effort toward core\ncoding tasks and away from project management and coordination activities.\nWhile AI-assisted code development promises substantial productivity gains, its implications for software\nmaintenance remain less well understood. Prior research on software development has long recognized that\ndevelopment costs are often small relative to maintenance costs, which include sustaining activities associ-\nated with ensuring software quality and security (Nagle 2019). In the case of OSS, while users can benefit\nfrom reduced up-front costs, collective intelligence of the crowd, and flexibility to implement changes, the\nchallenges of maintenance get magnified as contributors are not contractually obligated to maintain the\nsoftware (von Hippel and von Krogh 2003, Nagle 2019). The Linux Foundation\u2019s OSS Contributor Sur-\nvey provides insightful perspectives on the complexities involved in maintaining OSS (Nagle et al. 2020).\nFirstly, it highlights that \u201cgeneral housekeeping\" tasks, such as project maintenance, bug reporting and\ndocumentation, and organizational or administrative duties, often consume a more significant portion of\ncontributors\u2019 time than desired. Secondly, despite a preference among contributors to spend less time on\nmaintenance tasks, there\u2019s a broad acknowledgment of the importance of these activities, especially those\nrelated to software security, for the success and integrity of their projects (Nagle et al. 2020).\nFurthermore, AI code assistants, including prompt-based and \u201cvibe coding\u201d practices, promise to increase\nproductivity while easing access for contributors to submit code, even in complex and mature OSS projects.\nRecent work has begun to examine vibe coding as an emerging and controversial paradigm in AI-assisted\nsoftware development, in which programmers rely on natural language interaction with generative models\nto maintain flow and rapidly explore solutions, often with minimal upfront specification (Pimenova et al.\n2025, Fawzy et al. 2025). While this approach can substantially accelerate development and foster exper-\nimentation, the literature consistently highlights associated risks, including underspecified requirements,\nreduced reliability, difficulties in debugging, increased latency, and heavier burdens on code review and col-\nlaboration (He et al. 2025). A recurring theme is a speed\u2013quality paradox (Fawzy et al. 2025): although vibe\ncoding enables rapid"
    },
    {
      "rank": 3,
      "distance_l2": 0.7946469783782959,
      "source_id": "AIProdDecrease2024",
      "chunk_id": "AIProdDecrease2024_chunk_002",
      "text": " team member who partners with the developer to create knowledge (Friedman\n2021). Unlike earlier coding automation tools that primarily targeted productivity, GitHub Copilot\u2019s framing\nas a pair programmer signals a deeper shift. It implies that AI may fundamentally reshape how knowledge-\nintensive work is performed, coordinated, and organized, rather than merely accelerating existing tasks.\nFor organizations and communities involved in software development, the addition of AI pair program-\nmers in teams offers the potential for significant productivity gains. Right after the launch of GitHub Copi-\n1\narXiv:2510.10165v3  [econ.GN]  28 Jan 2026\n2\nlot, research shows that developers who use Copilot completed their programming tasks 55.8% faster (Peng\net al. 2023). Such productivity benefits lead to promises of faster time-to-market and increased revenue\nfor organizations developing software applications. Considering these shifts, major tech organizations have\nstarted to increasingly rely on AI in their projects - \u201cmore than a quarter of all new code at Google is gen-\nerated by AI, then reviewed and accepted by engineers,\" reported Google CEO Sundar Pichai in January,\n2025.1 Moreover, Microsoft CTO Kevin Scott expects that 95% of all code will be AI-generated by 2030.2\nWhile these productivity gains are promising, they also raise important questions about the quality and\nmaintainability of AI-generated code. Because AI tools can lower the skill barrier for writing code (Dakhel\net al. 2023), AI tools enable broader participation but may also encourage developers to rely on gener-\nated solutions without fully understanding the underlying design rationale and potential integration issues\n(Barrett et al. 2023). Such reliance increases the likelihood of quick fixes that favor short-term function-\nality over long-term maintainability (Barrett et al. 2023). Extant literature characterizes \u201cquick and dirty\u201d\nsoftware customizations made without a complete understanding of their future implications as technical\ndebt, as they undermine system reliability and impose long-term maintenance obligations (Kruchten et al.\n2012, Brown et al. 2010, Banker et al. 2021). As a result, project maintainers must devote additional effort\nto understanding, reviewing, and reworking AI-generated code before it can be safely integrated. In our\ncontext, we contend that the growing reliance on AI-assisted development may accelerate the accumulation\nof technical debt, as design shortcuts taken to expedite system deployment become embedded in software\nsystems (Ramasubbu and Kemerer 2016, 2021).\nThe technical debt and maintenance challenges that AI poses are expected to be especially pronounced\nin distributed software development teams, such as in Open Source Software (OSS) communities. In these\ncommunities, contributors from around the world collaborate, often voluntarily, to develop and maintain\nsoftware that form the digital infrastructure of our society (e.g., Linux, Apache, LaTeX, Python), making\nit freely or cheaply available to the public (Eghbal 2020, Nagle 2019). Despite the voluntary nature of\nwork in these communities, OSS constitutes critical digital infrastructure for modern society, with estimates\nsuggesting that the total cost of reproducing this software would amount to $8.8 trillion (Hoffmann et al.\n2024).3 Given"
    },
    {
      "rank": 4,
      "distance_l2": 0.8206110000610352,
      "source_id": "CopilotCACM2022",
      "chunk_id": "CopilotCACM2022_chunk_001",
      "text": "CODE-COMPLETION SYSTEMS OFFERING suggestions \nto a developer in their integrated development \nenvironment (IDE) have become the most frequently \nused kind of programmer assistance.1 When \ngenerating whole snippets of code, they typically use \na large language model (LLM) to predict what the user \nmight type next (the completion) from the context of \nwhat they are working on at the moment (the prompt).2 \nThis system allows for completions at any position in \nMeasuring \nGitHub \nCopilot\u2019s \nImpact on \nProductivity\nDOI:10.1145/3633453\nCase study asks Copilot users about its impact \non their productivity, and seeks to find their \nperceptions mirrored in user data.\nBY ALBERT ZIEGLER, EIRINI KALLIAMVAKOU, X. ALICE LI, \nANDREW RICE, DEVON RIFKIN, SHAWN SIMISTER, \nGANESH SITTAMPALAM, AND EDWARD AFTANDILIAN\n key insights\n\t\n\u02fd AI pair-programming tools such as GitHub \nCopilot have a big impact on developer \nproductivity. This holds for developers \nof all skill levels, with junior developers \nseeing the largest gains.\n\t\n\u02fd The reported benefits of receiving AI \nsuggestions while coding span the full \nrange of typically investigated aspects of \nproductivity, such as task time, product \nquality, cognitive load, enjoyment, and \nlearning.\n\t\n\u02fd Perceived productivity gains are reflected \nin objective measurements of developer \nactivity.\n\t\n\u02fd While suggestion correctness is \nimportant, the driving factor for these \nimprovements appears to be not \ncorrectness as such, but whether the \nsuggestions are useful as a starting point \nfor further development.\n54    COMMUNICATIONS OF THE ACM  |  MARCH 2024  |  VOL. 67  |  NO. 3\nresearch\nthe code, often spanning multiple \nlines at once.\nPotential benefits of generating \nlarge sections of code automatically \nare huge, but evaluating these sys\u00ad\ntems is challenging. Offline evalua\u00ad\ntion, where the system is shown a par\u00ad\ntial snippet of code and then asked \nto complete it, is difficult not least \nbecause for longer completions there \nare many acceptable alternatives and \nno straightforward mechanism for \nlabeling them automatically.5 An ad\u00ad\nditional step taken by some research\u00ad\ners3,21,29 is to use online evaluation \nand track the frequency of real us\u00ad\ners accepting suggestions, assuming \nthat the more contributions a system \nmakes to the developer\u2019s code, the \nhigher its benefit. The validity of this \nassumption is not obvious when con\u00ad\nsidering issues such as whether two \nshort completions are more valuable \nthan one long one, or whether review\u00ad\ning suggestions can be detrimental to \nprogramming flow.\nCode completion in IDEs using lan\u00ad\nguage models was first proposed in \nHindle et al.,9 and today neural syn\u00ad\nthesis tools such as GitHub Copilot, \nCodeWhisperer, and TabNine suggest \ncode snippets within an IDE with the \nexplicitly stated intention to increase \na user\u2019s productivity. Developer pro\u00ad\nductivity has many aspects, and a re\u00ad\ncent study has shown that tools like \nthese are helpful in ways"
    },
    {
      "rank": 5,
      "distance_l2": 0.8404721021652222,
      "source_id": "OpenSourceImpact2024",
      "chunk_id": "OpenSourceImpact2024_chunk_032",
      "text": " structure, developers are generally not \nassigned with tasks. Instead, they voluntarily select areas in which they wish to contribute. Given that open-\nsource projects often adopt modular architectures and support parallel development (Howison and \nCrowston 2014, Medappa and Srivastava 2019), core and peripheral developers may contribute \nsimultaneously to similar features, effectively working on the same tasks. As such, task reallocation from \nperipheral to core developers may not be a likely explanation for the observed pattern. \n7. Discussion and Conclusions \nThe rise of AI pair programmers has garnered increasing attention due to their potential to transform \nsoftware development. In this study, we explore the effects of AI pair programmers within the context of \ncollaborative OSS development, with a focus on their impact on project-level code contributions and \ncoordination time for code integration. Using repository-level proprietary data from GitHub organization, \n 34 \nwe evaluate the impact of GitHub Copilot, an AI pair programmer, on the development outcomes of open-\nsource repositories, along with its underlying mechanisms.  \nOur findings indicate that Copilot adoption significantly increases project-level code contribution \nalongside longer coordination time, highlighting a tradeoff between facilitated code generation and \nheightened coordination cost in collaborative software development. Mechanism analyses reveal that the \nincreased project-level code contributions are driven by more developers in participating in coding and \ngreater individual code contributions. In contrast, the increased coordination time seems driven by greater \ncode discussions, including higher code discussion volumes, more developers participating in code \ndiscussions, and greater discussion intensity per developer. We extend prior research on generative AI's \nproductivity benefits for individual developers (e.g., Peng et al. 2023; Cui et al. 2024) by examining its \nimpact on collaborative, voluntary participation in open-source software (OSS) projects. We also contribute \nto the literature on the role of generative AI in team collaboration. Unlike earlier work focused on traditional \nteams with fixed roles and structured coordination (Li et al. 2024, Dell'Acqua et al. 2025), we explore fluid, \nvolunteer-driven OSS environments. We reveal that AI tools, by encouraging engagement in discussions, \nmay increase coordination time due to the need to align diverse perspectives. \nWe also examine the effects of Copilot on core and peripheral developers within the OSS \ncommunity, who differ in their levels of familiarity with the focal projects. Our analysis shows that, \nfollowing Copilot adoption, peripheral developers experienced a relatively smaller increase in project-level \ncode contributions but a larger increase in coordination time, when compared to core developers. In addition, \nwe find that peripheral developers contribute a smaller proportion of timely integrated code, suggesting that \nthe productivity gain from AI pair programmers could be less for peripheral developers than for core \ndevelopers. Prior studies (e.g., Dell\u2019Acqua et al. 2023; Peng et al. 2023) show that less-skilled users often \nbenefit more from AI tools. In contrast, we find that in OSS settings where developers handle complex \nsoftware development projects, core developers gain more from AI pair programming than peripheral ones, \nlikely due to their greater contextual knowledge of the project.  \n7.1 Implications \n 35 \nOur paper has several implications for both practice and the broader OSS communities. First, our findings \nsuggest that organizations should invest in AI pair"
    },
    {
      "rank": 6,
      "distance_l2": 0.864033043384552,
      "source_id": "CopilotExperiment2023",
      "chunk_id": "CopilotExperiment2023_chunk_004",
      "text": "the treatment group how helpful they found GitHub Copilot as they worked on the task, as well\nas asked them to estimate how much faster they completed the task compared to how long this\ntask would have taken them without using GitHub Copilot. We also asked the control group to\nestimate the size of the speed gain they would have experienced if they used GitHub Copilot,\nafter showing them a 1-minute demo video.\nResults\nA total of 166 offers were sent during the experiment, and 95 were accepted. The 95 developers\nwere randomly assigned into control and treated groups, with 45 in the treated group and 50 in\ncontrol. Thirty-\ufb01ve developers from both the treated and control groups completed the task and\nsurvey. Figure 5 presents the summary statistics of these participants.\nMost of the participants are in the age group of 25-34 and come from India and Pakistan.\nThis group of participants is also characterized by relatively lower income (median yearly in-\ncome between $10,000-$19,000) compared to US standards but high education level (the ma-\njority have a 4-year degree and above). The group has an average coding experience of 6 years\nand, on average, reported spending 9 hours on coding in a working day.\nFigure 6 plots the distribution between time to completion between treated and control\ngroups. Conditioning on completing the task, the average completion time from the treated\ngroup is 71.17 minutes and 160.89 minutes for the control group. This represents a 55.8% re-\nduction in completion time. The p-value for the t-test is 0.0017, and a 95% con\ufb01dence interval\nfor the improvement is between [21%, 89%]. There are four outliers with time to completion\nabove 300 min. All outliers are in the control group, however our results remain robust if these\noutliers are dropped. This result suggests that Copilot increases average productivity signif-\nicantly in our experiment population. We also \ufb01nd that the treated group\u2019s success rate is 7\n5\nTable 1: Heterogeneous Treatment Effects\nEstimates\nSE\nt-Stat\np-Value\n(Intercept)\n78.01\n67.84\n1.15\n0.2552\nProgramming experience (years)\n8.23\n4.36\n1.90\n0.0629\nHours of programming per day\n-11.70\n4.74\n-2.47\n0.0168\nAge: 25-44\n-74.55\n33.52\n-2.22\n0.0303\nUnemployed\n-35.98\n36.33\n-0.99\n0.3263\nIncome less than $20,000\n0.64\n27.47\n0.02\n0.9814\nNo college\n-36.57\n32.89\n-1.11\n0.2711\nLanguage Preference: Java\n-11.77\n33.16\n-0.35\n0.7240\nLanguage Preference: Python\n22.90\n42.19\n0.54\n0.5895\nNote: This table presents the heterogeneous treatment effects. The results suggest developer with less program-\nming experience are more likely to bene\ufb01t from"
    },
    {
      "rank": 7,
      "distance_l2": 0.9335917830467224,
      "source_id": "CopilotQuality2022",
      "chunk_id": "CopilotQuality2022_chunk_003",
      "text": ". GitHub Copilot generates the code\nand presents the results of the OpenAI Codex Model by adjusting\nthe generated code to the current workspace of the programmer\n[4]. The Codex model relies on Generative Pre-trained Transformer\n(GPT) models that the company previously invented for text gen-\neration. The public code available on GitHub was used during the\nfine-tuning of the model to implement the code recognition and\ngeneration capabilities.\nThere are mixed reviews about the prospect of the GitHub Copi-\nlot. On the one hand, reducing development time, easing the devel-\nopment process by suggesting code for small utilities, and suggest-\ning better alternatives for code snippets are some of the positive\nfeedback developers provided [2, 7, 13]. On the other hand, it is\nargued that the current state of technology is not promising enough\nto match human ingenuity. Considering the previous studies, the\nservice requires a vast amount of human interaction, making the\ncoding routine still heavily reliant on the programmer [1].\nThe reviews about GitHub Copilot we touched upon only in-\nclude brief and heuristic feedback in terms of the evaluation of the\nservice. We agree with the general consensus of the opinions about\nGitHub Copilot and find it worthwhile to evaluate the possible en-\nhancements a service like GitHub Copilot can offer. Clearly, GitHub\nCopilot is capable of generating code, but its value is undetermined.\nTo systematically evaluate GitHub Copilot, we propose to construct\nan experimental setup to assess the generated code in terms of\nvalidity, correctness, and efficiency. In this context, we defined the\nfollowing research questions:\nRQ1 What is the quality of the code generated by GitHub Copilot?\nRQ1.1 How valid are GitHub Copilot\u2019s code suggestions?\nRQ1.2 How correct are GitHub Copilot\u2019s code suggestions?\nRQ1.3 How efficient are GitHub Copilot\u2019s code suggestions?\nRQ2 What is the effect of using the docstrings on the generated\ncode quality?\nRQ3 What is the effect of using appropriate function names on the\ngenerated code quality?\nIn the following sections, we first elaborate on our experimental\nsetup in Section 2. In Section 3, we present the results we gathered\nfrom our setup. In Section 4, we share and evaluate our results. In\n1copilot.github.com\n2openai.com/blog/openai-codex/\n3github.com/features/codespaces\n62\nPROMISE \u201922, November 17, 2022, Singapore, Singapore\nBurak Yetistiren, Isik Ozsoy, and Eray Tuzun\nSection 5, we discuss factors that might influence the validity of our\nresults. We provide an overview of other works that study GitHub\nCopilot in Section 6. Lastly, we conclude our study in Section 7.\n2\nMETHODOLOGY\nIn our experiment, we used HumanEval dataset [3], which is de-\nscribed in Section 2.1. To address the research questions, we created\nan experimental setup, which systematically evaluates the effective-\nness of GitHub Copilot that is described in Section 2.2. The details\nof our assessment are presented in Sections 2.3\u20132.5. In Sections\n2.6 and 2.7, we elaborate on the two additional experiments we\ncon"
    }
  ],
  "citations": []
}